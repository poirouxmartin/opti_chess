----- Documentation pour la suite -----

https://cs229.stanford.edu/proj2012/DeSa-ClassifyingChessPositions.pdf
https://www.wikiwand.com/en/Negamax
https://thesai.org/Downloads/Volume5No5/Paper_10-A_Comparative_Study_of_Game_Tree_Searching_Methods.pdf
https://www.chessprogramming.org/Evaluation_of_Pieces
https://www.chessprogramming.org/Evaluation
https://www.cs.cornell.edu/boom/2004sp/ProjectArch/Chess/algorithms.html#board
https://www.chessprogramming.org/Main_Page
https://towardsdatascience.com/building-a-chess-ai-that-learns-from-experience-5cff953b6784
https://arxiv.org/pdf/1711.08337.pdf
https://stackoverflow.com/questions/40137240/training-of-chess-evaluation-function
https://arxiv.org/pdf/2007.02130.pdf
https://www.chessprogramming.org/Move_Generation
https://www.chessprogramming.org/Checkmate
https://www.chessprogramming.org/Bishop_versus_Knight#WinningPercantages
https://www.chessprogramming.org/Sensor_Chess#MoveGeneration
https://hxim.github.io/Stockfish-Evaluation-Guide/
https://www.chessprogramming.org/Repetitions
https://en.wikipedia.org/wiki/Threefold_repetition
https://www.chessprogramming.org/Opening_Book
https://www.chessprogramming.org/Pawn_Structure
https://www.chessprogramming.org/Time_Management
https://www.chessprogramming.org/Encoding_Moves#MoveIndex
https://lichess.org/page/accuracy
http://www.talkchess.com/forum3/viewtopic.php?f=2&t=68311&start=19
https://www.chessprogramming.org/UCT
https://www.codeproject.com/Articles/5313417/Worlds-Fastest-Bitboard-Chess-Movegenerator


----- Jeu -----

-> Promotions (de tous types plutôt que seulement dame)
-> Rajouter des tests de validité de FEN
-> Répétition de coups
-> Pouvoir naviguer dans l'historique des coups


----- Structure globale du projet -----

-> Séparer les fonctions du fichier opti_chess dans d'autres fichiers (GUI, IA...)
-> Faire du ménage dans les fonctions
-> Faire une classe pour les IA?


----- Optimisations à implémenter -----

-> Regarder quel compilateur est le plus rapide/opti
-> Algo Negamax -> copies des tableaux -> undo moves? ---> finalement plus lent?
-> Transposition tables
-> Algorithme MTD(f) <-> alphabeta with memory algorithm
-> stoi et to_string très lents?
-> Ajout de variables globales plutôt que les re définir lors des appels de fonction (valeur des pièces, positionnement...)
-> Parallélisation -> std::for_each avec policy parallel?
-> Au lieu de calculer l'évaluation à chaque coup, l'imcrémenter en fonction du coup
-> Dans le negamax, si y'a un mat, ne plus regarder les autres coups?
-> Optimiser le sort moves - l'améliorer (et l'évaluation?)
-> Remplacer des if par des &&
-> Vérifier que toutes les fonctions sont optimisées
-> Faire le triage des coups grâce aux itérations précédentes?
-> Fonction pour stocker facilement un noeud, ou savoir s'il est similaire à un autre? -> transposition tables
-> Incrémenter le game_over à chaque coup joué plutôt que de le regarder à chaque fois
-> Regarder si l'implémentation des échecs rend les calculs plus rapides
-> Ne plus jouer les échecs?
-> Copie des plateaux : tout copier? ou seulement quelques informations importantes?
-> Liste des coups légaux, et une autre liste pour les coups pseudo-légaux... pour éviter de les recalculer à chaque fois...
-> Utiliser les threads.. voir cours ProgrammationConcurrente
-> Checker SIMD code (pour optimiser)
-> Calcul de distance à un bord : simplement faire une matrice globale des distance pour chaque case, et regarder dedans -> https://www.chessprogramming.org/Center_Manhattan-Distance
-> Faut-il stocker les positions de certaines pièces (les rois par exemple), pour accélérer certains calculs?
-> Regarder dans les copies de tableau si on peut ne pas copier des choses, ou en copier plus...
-> Précalculer pas mal de choses si possible
-> Incrémentation de l'évaluation


----- Intelligences artificielles -----

--- Nouveaux algorithmes ---

-> Grogrofish_iterative_depth -
-> Changer Grogrosfish : depth -> temps (--> moteur d'analyse)
-> Faire une profodeur -> trier les coups du meilleur au pire, puis continuer la recherche plus loin
-> Agent_new = Agent_old++ -
-> Faire un agent qui gagne toujours contre un autre : regarde tous les coups, et joue pour chacun la partie jusqu'au bout en utilisant agent_old -> puis joue les coups qui gagnent
-> RE : multi_agents

--- Améliorations ---

- EVALUATION -
-> A ajouter :
	- Sécurité du roi (TRES IMPORTANT !) --> A améliorer
	- Structures de pions :
		- Pions arriérés
	- Nature de la position :
		- Ouverte
		- Fermée
		- Semi-ouverte
	- Evaluation spéciale pour les finales :
		- Fous de couleurs opposées
		- Finales roi pion
		- Mat fou cavalier
		- ...
	- Clouages?
	- Cases noires/blanches -> faiblesse sur une couleur
	- Cases faibles
	- Initiative -> A améliorer : fort dans les positions d'attaque?
	- Fous de couleurs opposées : favorisent l'attaque, mais en finale -> draw
	- Harmonie des pièces (qui se défendent entre elles)
	- Pièces enfermées
	- Bon/Mauvais fou
	- Tours sur une même colonne qu'une dame ou un roi
	- Pions bloqués / Développement de pièces impossible
	- Fous/Paire de fou meilleurs en position ouverte (cavalier : inverse)
	- Pièces défendues
	- Faiblesse sur une couleur
	- Vis-à-vis
	- Focales
	- Cavaliers bloqueurs
	- Finales de pions : Roi dans le carré
	- Garder les tours pour faire nulle
	- Clouage infini
	- Pression sur les cases et points faibles
	- Colonnes occupées par une dame
	- Pions passés liés !
	- Outpost
	- Pawn push threat (on le pousse et ça attaque une pièce)
	- Passed block (si y'a qq chose qui bloque un pion passé) : ajouter le contrôle des cases devant le pion passé
	- Coordination des pièces
	- Bishop pawns : nombre de pion de la même couleur que le fou -> pénalité plus le nombre est grand
	- Candidats pions passés : r1bq2kr/ppp1bn1p/2n1p2P/3pP1PR/3P1p2/1NPB1N2/PPQ2P2/R3K3 b Q - 0 16 : ici y'aura potentiellement un pion passé colonne g ou h
	- King proximity : proximité du roi avec les pions passés (pour les aider à avancer) (prendre en compte aussi le roi adverse)
	- Pièces non protégées
	- Shelter strength : pions devant le roi (faiblesses long terme)
	- "anaconda" : pièces bloquées à vie + avantage d'espace etc.. plans long termes
	- Hanging pieces : pièces non protégées
	- Concepts de pression: attaques additionelles en rayon X à prendre en compte. Doubler les tours sur une colonne, etc...
	- Marrées de pions : attaque sur le roi

-> Faire une policy pour les coups
-> Livres d'ouvertures, tables d'engame?
-> Tables de hachages, et apprentissage de l'IA? -> voir tp_jeux (UE IA/IRP)
-> Iterative deepening pour grogrosfish
-> Améliorations pour trouver les mats les plus rapides... 
-> Ne plus regarder les branches finies de GrogrosZero
-> Utiliser raylib pour le random? check la vitesse
-> Création d'une base de données contenant des positions et des évaluations? (qui se remplit au cours des parties...)
-> Allocations mémoires utilisant raylib?
-> Implémentation de bitboards
-> Changer la structure de données des boards pour réduire leur taille
-> Incrémentation de l'évaluation quand on joue les coups (make_move(keep))
-> Utiliser la librairie boost
-> Faire une liste séparée pour les legal et les pseudo-legal moves
-> Génération des coups de façon ordonnée? (captures en premier?)
-> Finir les undo
-> Mettre des options pour certaines fonctions pour ne pas faire les étapes inutiles (_last_move dans make_move??)
-> Faire une fonction pour initialiser un plateau (plutôt que le from_fen)
-> Faire que les undo gardent les calculs de GrogrosZero sur la position
-> Augmenter les poussées de pions en finale (les regarder en premier -> policy / move sort)
-> Faire une IA qui apprend tout seul? : update l'évaluation d'une position en fonction de la refléxion sur cette même position
-> Générer un arbre d'ouvertures !! :DDDD
-> Evaluation des pièces : prendre en compte les pièces protégées / attaquées? Pièces prenables?
-> Format du livre d'ouvertures : {(e4, fen, static_eval, dynamic_eval, nodes, {(e5, ...), (...), ...}), (d4, ...), ...}. où e4 = 1, 4, 3, 4
-> Pour l'utilisation du livre, re fabriquer un arbre?
-> Faire une table de hachage pour simplifier (et accélérer) la recherche des positions répétées
-> Pour l'historique des positions, on peut le reset à chaque coup de pion ou capture
-> Pour les transpositions, on peut peut-être renvoyer au même indice de plateau fils...?
-> Pour chaque plateau, générer et stocker la representation simpliste du plateau? Pour ensuite pouvoir aider les fils à comparer?
-> ATTENTION aux conversions int et float dans les calculs d'évaluations...
-> Mettre les règles de parties nulles et mat en dehors de l'évaluation?
-> Ajouter les pièces protégées/attaquées lors de l'évaluation pour simplifier les calculs de l'IA
-> Carré du pion en finales
-> Ne comprend pas les finales de bases (du au fait qu'il répète les coups?)
-> Regarder dag chess?
-> Faire une map des cases attaquées (ça peut rendre plus rapide les tests d'échecs)
-> OpenAI propose un diviser pour reigner pour paralléliser GrogrosZero
-> Est-ce plus rapide de mettre des boucles simples plutôt que double? while plutôt que for?
-> Endgame : la force des pièces dépend du potentiel des pions (pièces seules = bof)
-> Refaire les game_over() de façon plus propre, et dire quand la partie est finie dans la GUI (+ son de fin)
-> Plein de calculs en double (voir appels de fonctions... is_mate()?)
-> Faire des tables d'attaque (par exemple entre roi et dame, cavalier...)
-> Refaire toute l'architecture avec les get_moves(), pour que ça prenne tout en compte (sans le faire dans l'évaluation)
-> Calculer l'avancement de la partie au fur et à mesure de la partie (au lieu de le faire à chaque fois)
-> GrogrosZero ralentit beaucoup quand les variantes deviennent longues
-> ----> Faire une recherche spécialement de mat, où on prend plus en compte le matériel??
-> Au fil de la réflexion, retirer les coups pourris?? pour augmenter la capacité de stockage...
-> Mettre une variable globale pour la règle des 50 coups (pour la passer à moins, si besoin)
-> Rechercher large au début, puis serré après??
-> Changer un peu l'algo, pour que ça ne joue pas forcément le coup auquel il a le plus réflechi, mais un autre si il semble être meilleur (quand c'est mat, facile, mais sinon, comment savoir?)
-> Attaquer les faiblesses
-> Quand Grogros joue un coup auquel il n'avait pas pensé.. les évaluations déscendent pour les coups, 1 par 1... comment faire pour que tout descende en même temps?
-> Regler tous les *100 et les /100 dans les évaluations
-> L'éval statique en position symétrique sera toujours nulle ?? (modulo le trait du joueur)
-> Puissance de la paire de fou qui dépend du moment de la partie? Qui dépend si y'a encore les dames pour compenser?
-> Découper la foncion draw en plein de sous-fonctions?
-> Chercher ce qui prend le plus de temps dans la GUI
-> Recherche de Grogros : utiliser UCT
-> Tester Grogros sur les leçons stratégiques de chess.com
-> Mettre des static const un peu partout pour éviter les re définitions inutiles
-> Faut-il prendre en compte le nombre de noeuds dans un fils pour déterminer s'il faut regarder dedans?
-> Ordonnencement des coups : checks/captures/attacks
-> Dans les positions ou des pièces peuvent être capturées, Grogros évalue très mal (quiescence depth trop faible)
-> Retirer les espace dans les parsing de FEN (ou autres caractères non désirés)
-> Passer tous les commentaires en anglais et clean le code?
-> Evaluations en finales : un cavalier seul sans pions ni rien = nul
-> Mettre les noms de version sur le nom de Grogros
-> Utiliser toutes les améliorations/optimisations possibles sur VisualStudio
-> Mettre des uint_fast8_t partout
-> Negamax : utiliser les plateaux tout faits du buffer?
-> Mettre des variables globales partout !
-> Virer les attributs inutiles des plateaux
-> Faire une fonction qui regarde si un coup est légal
-> Regarder et virer toutes les conversions de int à float, et opérations entre int et floats
-> Position à tester : GrogrosZero vs Grogrosfish : 
	-> r1bqkb1r/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 : sans cavaliers
	-> rn1qk1nr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 : sans fous
	-> 1nbqkbn1/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w - - 0 1 : sans tours
	-> rnb1kbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 : sans dame
	-> rnbqkbnr/8/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 : sans pions
-> Nouveau gros bug : quand on fait réfléchir grogros, qu'on supprime et qu'on lance grogrosfish, ça crash (ça peut crasher)
-> Faire des pre-calculs dans des constantes (genre des divisions), pour éviter de les faire à chaque fois
-> Mettre des flags pour les coups (capture, check, promotion -> caval possible??)
-> Descendre un peu le winrate par éval? réference : +1.00 = 50% de chances de gain
-> Quels paramètres sont meilleurs pour GrogrosZero? k_add? beta? quiescence_depth?
-> Utiliser std:sort pour trier les coups plus rapidement?
-> Alignement de pièces à finir (tour/roi, tour/dame...)
-> Taper les faiblesses (notions de pression)
-> Réduire la puissance des fous : un cavalier bien placé peut être tout aussi bon -> Outpost
-> Utiliser la map de contrôles pour les fonctions dans l'évaluation
-> Quand l'arbre est trop plein : élaguer les branches pourries, pour se concentrer sur les plus prometteuses
-> Faut-il vraiment regarder tous les coups d'une position avant de chercher plus loin??
-> Evaluer les finales différemment : faires des fonctions exprès pour (carré du pion, mat fou cavalier : il faut aller dans le bon coin)
-> Optimiser la mémoire de Grogros
-> Ajouter la nature de la position : ouverte, fermée... pour savoir à quel point les fous/cavaliers sont meilleurs, si y'a des chances de gain, si le développement des pièces compte beaucoup... l'espace aussi, la sécurité des rois...
-> Améliorer l'implémentation de l'activité des pièces : peuvent pas vraiment se déplacer sur des cases pourries...
-> Pour mieux évaluer la sécurité du roi, il faut regarder le surnombre de pièces sur le roi adverse (+2, c'est généralement mat)
-> Pourquoi dans les Caro-Kann, il fait Fd3 pour reprendre du pion c plutôt que de la dame?
-> Faire que Grogros reclique sur la fenêtre principale après jouer son coup sur chess.com pour reprendre la main? ou alors faire un focus sur la fenêtre?
-> Utiliser des static constexpr pour éviter des calculs redondants dans certaines fonctions
-> Il faut plus de g3 Fg2 -> revoir king safety?
-> Re utiliser la réflexion de la quiescence search pour la recherche normale
-> Faire evaluation.cpp? gui.cpp?
-> Comme pour le roi, garder en mémoire l'emplacement des pièces (utiliserait 256 bytes)
-> Afficher seulement les paramètres d'évaluation qui font sens? (par exemple king opposition seulement lorsque c'est une finale de pions)
-> Tout foutre dans la classe GUI? les variables globales et fonctions globales en particulier -> par exemple eval_components
-> Adapter les fonctions aux coups (make_move(Move)...)
-> Faire des méthodes utiles pour les coups
-> Verifier que quiescence depth 0 est aussi rapide qu'une simple évaluation
-> Flags pour les coups
-> Rendre from_fen plus tolérant
-> Améliorer l'évaluation en faisant jouer contre Leela, et regarder ce que Grogros évalue mal
-> Eviter les accès à _moves[i] trop souvent? -> copier le coup?
-> IMPORTANT : refaire toutes les recherches de mat, et leur stockages
-> Faire le threading !
-> Faire un king_centralization pour l'endgame?
-> Voir comment gérer les positions qui sont mal évaluées par GrogrosZero
-> Implementer les policy pour les coups (pour regarder des coups plus que d'autres)
-> Pion de moins en finale de pions est quasi toujours perdant
-> Ajouter la pièce dans le coup (et l'utiliser)
-> Revoir les undo, et les faire rapides pour les utiliser au lieu de copier les plateaux
-> Faire des tests de vitesse pour l'évaluation
-> Evaluation endgame très mauvaise
-> Quand une position est surestimée, Grogros va jouer des coups pour retarder l'échéance, mais qui peuvent pourrir la position encore plus
-> Quand une position est sous-estimée, Grogros va jouer un coup qui parait bien et réfléchir beaucoup dessus, même si d'autres variations peuvent être meilleures
-> Revoir negamax
-> Utiliser sort c++ pour trier les coups
-> Rajouter les coups du quiescence dans monte-carlo, et inversement... -> mettre le quiescence dans MCTS?
-> Remettre la dame dans la mobilité des pièces et l'activité? pour que ça développe la dame aussi? Sinon, ça évalue mal ces positions: r1b1kbnr/ppqp1ppp/2n1p3/8/3NP3/2N5/PPP2PPP/R1BQKB1R w KQkq - 1 6 
-> r1bqkb1r/ppp2ppp/2n1p3/8/3PP3/2P5/P4PPP/R1BQKBNR w KQkq - 0 7 : piece_mobility seulement +0.18? c'est un bug?
-> Dans la recherche de grogros_zero, regarder en priorité les coups forts et peu regardés
-> REFAIRE TOUTE LA PARTIE SUR IS_GAME_OVER -> NE PAS METTRE DANS LA FONCTION D'EVALUATION!!
-> Detection plus rapide d'échecs et mat



----- Interface utilisateur -----

-> Faire un readme pour les contrôles
-> Amélioration des sons (en faire des maison?)
-> Navigation dans les coups de la partie avec les flèches (il faut donc stocker l'ensemble de la partie - à l'aide du PGN -> from_pgn?)
-> Nouveau sons/images
-> Dans le negamax, renvoyer le coup à chaque fois, pour noter la ligne que l'ordi regarde?
-> Faire des boutons pour faire des actions (ex copier ou coller le FEN/PGN, activer l'IA ou la changer...)
-> Options : désactivation son, ...
-> Chargement FEN -> "auto-complétion" si le FEN est incorrect
-> Régler le clic (quand IA va jouer), qui affiche mal la pièce (grogrosfish)
-> Modification de l'incrément dans la GUI
-> Interface qui ne freeze plus quand l'IA réfléchit -> Paralléliser
-> Sons pour le temps
-> Premettre de modifier les paramètres de recherche de l'IA : beta, k_add... (d'une meilleure manière)
-> Musique de fond? (désactivable)
-> Ajouter un éditeur de positions (ajouter/supprimer les pièces)
-> Utiliser 1 thread pour gérer l'affichage tout seul
-> Undo doit retirer le coup du PGN aussi
-> Afficher les textes avec des différentes couleurs pour que ça soit plus facile à lire
-> Défiler la variante quand on met la souris dessus
-> Montrer sur l'échiquier quand la position est mate (ou pate, ou autre condition de fin de partie)
-> Faire un reconnaisseur de position automatique
-> Unload les images, textures etc... pour vider la RAM?
-> Pouvoir changer les paramètres de l'IA dans l'UI
-> Ajouter des options/menus
-> Pouvoir sauvegarder les parties entières dans un fichier (qui s'incrémente), pour garder une trace de toutes les parties jouées
-> Analyses de MC : montrer le chemin qui mène à la meilleure éval, puis celle qui mène au jeu qui va être joué
-> Pouvoir grab le slider, ou cliquer pour changer sa place
-> Faire des batailles entre différents paramètres d'évaluation pour voir la meilleure config -> Retour des batailles de NN?
-> Importation depuis un PGN
-> Afficher sur le PGN la reflexion de GrogrosZero
-> Pouvoir changer le nombre de noeuds de l'IA dans la GUI... ou la profondeur de Grogrosfish
-> Parfois l'utilisation des réseaux de neurones bug
-> Nd2f3 -> Ndf3? pas facile à faire
-> Ajouter la possibilité de faire plusieurs pre-move
-> Faire du smooth sur la barre d'évaluation
-> Faire un graphe d'éval en fin de partie?
-> Mettre des + sur les flèches (comme il y'a des -...)?
-> Faire un fonction pour tranformer une éval en son texte (mat ou non)
-> Certains calculs sont peut-être en double dans l'affichage
-> Echelle logarithmique pour la barre d'éval?
-> Gestion du temps bizarre? Car le temps affiché par GrogrosZero n'est pas vraiment le vrai (ni sa vitesse)
-> Clean l'implémentation de la GUI -> Faire des nouvelles fonctions pour tout simplifier
-> Faire un vecteur pour les pre moves et les flèches
-> Fins de parties : message + son
-> Dans une position que GrogrosZero sous-évalue, jouer le coup auquel il a le plus réflechi. dans le cas contraire, jouer le coup avec la meilleure éval
-> Barre d'éval : barre pour l'évaluation du coup le plus recherché par l'IA? ou éval du "meilleur coup"?
-> Mettre le screenshot dans le presse-papier?
-> Faire un truc pour montrer la menace (changer le trait du joueur)
-> Pouvoir éditer les positions
-> PARALLELISER L'AFFICHAGE !! ça lag beaucoup trop !!!
-> Refaire les pre-moves depuis zero (et ajouter la possibilité d'en faire plusieurs)
-> Faire un arbre pour la partie actuelle analysée, pour pouvoir avancer ou reculer dedans, faire une nouvelle variante...
-> Trop de flèches = crash
-> Lignes de bézier et cercles pas très beaux
-> Nouveaux bruits de pièces plus "soft" + bruit d'ambiance?
-> Montrer toute la variante calculée avec des flèches (d'une couleur spéciale)
-> Thread : bug... parfois les coups joués ne sont pas les bons
-> Re foncer le noir des pièces?
-> Pourquoi dans certaines variantes, l'éval ne s'affiche pas à la fin??
-> Dans les .h, remettre les noms des arguments?
-> Rajouter des pre-moves pour Grogros si c'est un coup forcé en face
-> Pourquoi c'est lent de changer la taille de la GUI?
-> Pour la barre d'éval, on utiise le winrate?
-> Faire des maps pour afficher les paramètres d'évaluation (genre afficher les cases controllées, avec une couleur plus ou moins prononcée...)
-> Pouvoir facilement changer les paramètres de Grogros (quiescence depth, beta, k_add, paramètres d'évaluation...)
-> Pouvoir changer l'affichage de la GUI (winrate/eval)
-> Faire des menus
-> Désélectionner les pièces lors d'un chargement de position
-> Mettre une évaluation de grogrosZero pour main_GUI._board pour pas que grogrosFish prenne le dessus
-> Utiliser des checkCollision de raylib pour la GUI
-> Afficher l'incrément de temps sur la GUI, et pouvoir le modifier
-> O-O+ dans les move label à prendre en compte
-> Revoir les update du temps quand on le change pendant que ça joue
-> Afficher des traits autour du plateau chess.com?
-> Affichage de la réflexion de Grogros sur le PGN : {N: 10.29% of 544}
-> Revoir le compare moves (sinon ça affiche pas toujours le meilleur coup au dessus)
-> Quand on arrive au mat dans le quiescence, l'affichage de l'éval bug (-99800000 au lieu de mat en 2)
-> Adapter nodes_per_frame en fonction du temps de réflexion de GrogrosZero (tant que la parallélisation n'est pas faite)
-> Montrer l'incrément sur la GUI
-> Afficher le titre et l'elo des joueurs sur la GUI
-> Revoir le tri des coups pour les flèches de GrogrosZero, car parfois ça ne se trie pas bien
-> Parfois quiescence speed -> négatif... (environ après 2.1M de noeuds...) -> calcul de la vitesse (sûrement à cause du * 1000)
-> Afficher différement la pièce sélectionnée (et au dessus des autres pièces)
-> Faire des animations de Grogros qui bouge les pièces
-> Quand on joue un coup (en appuyant sur p ou autre), il faut désélectionner la pièce
-> Refaire la réflexion de GrogrosZero: quand il y a beaucoup d'incertitude dans l'éval, regarder large. Sinon, regarder profond
-> Mobilité verticale ~= activité pour les tours?
-> Vérifier qu'il n'y a pas d'int overflow dans la sélection des coups (softmax...)
-> rnb2bnr/pppp1k1p/5q2/8/5p2/2N1BQ2/PPP3PP/R4RK1 b - - 3 11 : il évalue mal, et teste les coups 1 par 1 et se rend compte que ça va pas... beaucoup trop lent à ré évaluer la position correctement.



----- Réseaux de neurones -----

-> Faut t-il de la symétrie dans le réseau de neurone? (car sinon il évalue pas de la même manière les blancs et les noirs)