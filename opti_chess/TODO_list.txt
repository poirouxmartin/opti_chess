----- Documentation pour la suite -----

https://cs229.stanford.edu/proj2012/DeSa-ClassifyingChessPositions.pdf
https://www.wikiwand.com/en/Negamax
https://thesai.org/Downloads/Volume5No5/Paper_10-A_Comparative_Study_of_Game_Tree_Searching_Methods.pdf
https://www.chessprogramming.org/Evaluation_of_Pieces
https://www.chessprogramming.org/Evaluation
https://www.cs.cornell.edu/boom/2004sp/ProjectArch/Chess/algorithms.html#board
https://www.chessprogramming.org/Main_Page
https://towardsdatascience.com/building-a-chess-ai-that-learns-from-experience-5cff953b6784
https://arxiv.org/pdf/1711.08337.pdf
https://stackoverflow.com/questions/40137240/training-of-chess-evaluation-function
https://arxiv.org/pdf/2007.02130.pdf
https://www.chessprogramming.org/Move_Generation
https://www.chessprogramming.org/Checkmate
https://www.chessprogramming.org/Bishop_versus_Knight#WinningPercantages
https://www.chessprogramming.org/Sensor_Chess#MoveGeneration
https://hxim.github.io/Stockfish-Evaluation-Guide/
https://www.chessprogramming.org/Repetitions
https://en.wikipedia.org/wiki/Threefold_repetition
https://www.chessprogramming.org/Opening_Book
https://www.chessprogramming.org/Pawn_Structure
https://www.chessprogramming.org/Time_Management
https://www.chessprogramming.org/Encoding_Moves#MoveIndex
https://lichess.org/page/accuracy
http://www.talkchess.com/forum3/viewtopic.php?f=2&t=68311&start=19
https://www.chessprogramming.org/UCT
https://www.codeproject.com/Articles/5313417/Worlds-Fastest-Bitboard-Chess-Movegenerator


----- Jeu -----

-> Promotions (de tous types plutôt que seulement dame)
-> Rajouter des tests de validité de FEN
-> Répétition de coups
-> Pouvoir naviguer dans l'historique des coups


----- Structure globale du projet -----

-> Séparer les fonctions du fichier board dans d'autres fichiers (GUI, IA...)
-> Faire du ménage dans les fonctions
-> Faire une classe pour les IA?


----- Optimisations à implémenter -----

-> Regarder quel compilateur est le plus rapide/opti
-> Algo Negamax -> copies des tableaux -> undo moves? ---> finalement plus lent?
-> Transposition tables
-> Algorithme MTD(f) <-> alphabeta with memory algorithm
-> stoi et to_string très lents?
-> Ajout de variables globales plutôt que les re définir lors des appels de fonction (valeur des pièces, positionnement...)
-> Parallélisation -> std::for_each avec policy parallel?
-> Au lieu de calculer l'évaluation à chaque coup, l'imcrémenter en fonction du coup
-> Dans le negamax, si y'a un mat, ne plus regarder les autres coups?
-> Optimiser le sort moves - l'améliorer (et l'évaluation?)
-> Remplacer des if par des &&
-> Vérifier que toutes les fonctions sont optimisées
-> Faire le triage des coups grâce aux itérations précédentes?
-> Fonction pour stocker facilement un noeud, ou savoir s'il est similaire à un autre? -> transposition tables
-> Incrémenter le game_over à chaque coup joué plutôt que de le regarder à chaque fois
-> Regarder si l'implémentation des échecs rend les calculs plus rapides
-> Ne plus jouer les échecs?
-> Copie des plateaux : tout copier? ou seulement quelques informations importantes?
-> Liste des coups légaux, et une autre liste pour les coups pseudo-légaux... pour éviter de les recalculer à chaque fois...
-> Utiliser les threads.. voir cours ProgrammationConcurrente
-> Checker SIMD code (pour optimiser)
-> Calcul de distance à un bord : simplement faire une matrice globale des distance pour chaque case, et regarder dedans -> https://www.chessprogramming.org/Center_Manhattan-Distance
-> Faut-il stocker les positions de certaines pièces (les rois par exemple), pour accélérer certains calculs?
-> Regarder dans les copies de tableau si on peut ne pas copier des choses, ou en copier plus...
-> Précalculer pas mal de choses si possible
-> Incrémentation de l'évaluation


----- Intelligences artificielles -----

--- Nouveaux algorithmes ---

-> Grogrofish_iterative_depth -
-> Changer Grogrosfish : depth -> temps (--> moteur d'analyse)
-> Faire une profodeur -> trier les coups du meilleur au pire, puis continuer la recherche plus loin
-> Agent_new = Agent_old++ -
-> Faire un agent qui gagne toujours contre un autre : regarde tous les coups, et joue pour chacun la partie jusqu'au bout en utilisant agent_old -> puis joue les coups qui gagnent
-> RE : multi_agents

--- Améliorations ---

- EVALUATION -
-> A ajouter :
	- Sécurité du roi (TRES IMPORTANT !) --> A améliorer: lignes ouvertes et colonnes ouvertes proches du roi (ou semi-ouvertes)
	- Structures de pions :
		- Pions arriérés
		- Pion faible sur une colonne semi-ouverte
	- Nature de la position :
		- Ouverte
		- Fermée
		- Semi-ouverte
	- Evaluation spéciale pour les finales :
		- Fous de couleurs opposées
		- Finales roi pion
		- Mat fou cavalier
		- Finales de tours: plus facilement nulles
		- ...
	- Clouages?
	- Cases noires/blanches -> faiblesse sur une couleur
	- Initiative -> A améliorer : fort dans les positions d'attaque?
	- Fous de couleurs opposées : favorisent l'attaque, mais en finale -> draw
	- Harmonie des pièces (qui se défendent entre elles)
	- Pièces enfermées
	- Bon/Mauvais fou
	- Tours sur une même colonne qu'une dame ou un roi
	- Pions bloqués / Développement de pièces impossible
	- Fous/Paire de fou meilleurs en position ouverte (cavalier : inverse)
	- Pièces défendues
	- Faiblesse sur une couleur
	- Vis-à-vis
	- Focales
	- Cavaliers bloqueurs
	- Finales de pions : Roi dans le carré
	- Garder les tours pour faire nulle
	- Clouage infini
	- Pression sur les cases et points faibles
	- Colonnes occupées par une dame
	- Pions passés liés !
	- Coordination des pièces
	- Candidats pions passés : r1bq2kr/ppp1bn1p/2n1p2P/3pP1PR/3P1p2/1NPB1N2/PPQ2P2/R3K3 b Q - 0 16 : ici y'aura potentiellement un pion passé colonne g ou h
	- King proximity : proximité du roi avec les pions passés (pour les aider à avancer) (prendre en compte aussi le roi adverse)
	- Pièces non protégées
	- Shelter strength : pions devant le roi (faiblesses long terme), quand le roi est déroqué
	- Shelter storm : attaques avec les pions sur le roi quand il est déroqué
	- "anaconda" : pièces bloquées à vie + avantage d'espace etc.. plans long termes
	- Concepts de pression: attaques additionelles en rayon X à prendre en compte. Doubler les tours sur une colonne, etc...
	- Tours: les mettre sur les colonnes ou les pions sont les plus avancés (activité verticale)
	- Plans?
	- Colonnes fermées -> tour mauvaises. Si beaucoup de colonnes ouvertes, bonus pour les tours. Pareil pour les diagonales et les fous
	- Pions passés: prendre en compte les contrôles des alliés pour pousser les pions
	- Règle des 2 faiblesses : si y'a 2 faiblesses attaquables, ça donne un avantage
	- Winnable? en endgame par exemple si on a qu'un fou on peut pas gagner
	- Redonner de la valeur pour la dame, car les tours on beaucoup d'évaluations différentes qui leur donnent de la valeur
	- Quand t'as une position stratégiquement mauvaise, il faut jouer dynamiquement (r1bq1rk1/ppn1bppp/3p4/2p5/2PP4/2N1BN1P/PP3PP1/R2Q1RK1 b - - 0 14 : là faut faire d5)
	- Proximité du roi avec les pions passés
	- Trapped pieces (https://www.chessprogramming.org/Trapped_Pieces)
	- Connectivity (https://www.chessprogramming.org/Connectivity)
	- Pawn storms
	- Alignements
	- Open lines around king
	- Piece coordination
	- Incremental evaluation (pour que ça aille plus vite)
	- Tour derrrière un pion passé (implémenter les cases controlées pour les pions passés?)
	- Ouvrir la position si on a un avantage de développement (roi adverse pas roqué, pièces pas développées)
	- Développer les cavaliers avant les fous
	- Favoriser les chevaux dans les positions fermées. Fous quand les diagonales sont ouvertes, tours quand les colonnes sont ouvertes (implémenter un bonus pour chaque?)
	- Attaquer la chaîne de pions
	- Moins de pions = moins de chances de gagner en finale
	- Tours liées, important
	- Colonne ouverte/semi-ouverte contre le roi adverse combiné avec diagonale ouverte = grand avantage (+2?)
 


-> Faire une policy pour les coups (ou des préférences de réflexion)
-> Livres d'ouvertures, tables d'engame?
-> Tables de hachages, et apprentissage de l'IA? -> voir tp_jeux (UE IA/IRP)
-> Iterative deepening pour grogrosfish
-> Améliorations pour trouver les mats les plus rapides... 
-> Ne plus regarder les branches finies de GrogrosZero?
-> Utiliser raylib pour le random? check la vitesse
-> Création d'une base de données contenant des positions et des évaluations? (qui se remplit au cours des parties...)
-> Allocations mémoires utilisant raylib?
-> Implémentation de bitboards
-> Changer la structure de données des boards pour réduire leur taille
-> Incrémentation de l'évaluation quand on joue les coups (make_move(keep))
-> Utiliser la librairie boost
-> Faire une liste séparée pour les legal et les pseudo-legal moves
-> Génération des coups de façon ordonnée? (captures en premier?)
-> Finir les undo
-> Mettre des options pour certaines fonctions pour ne pas faire les étapes inutiles (_last_move dans make_move??)
-> Faire une fonction pour initialiser un plateau (plutôt que le from_fen)
-> Faire que les undo gardent les calculs de GrogrosZero sur la position
-> Augmenter les poussées de pions en finale (les regarder en premier -> policy / move sort)
-> Faire une IA qui apprend tout seul? : update l'évaluation d'une position en fonction de la refléxion sur cette même position
-> Générer un arbre d'ouvertures !! :DDDD
-> Evaluation des pièces : prendre en compte les pièces protégées / attaquées? Pièces prenables?
-> Format du livre d'ouvertures : {(e4, fen, static_eval, dynamic_eval, nodes, {(e5, ...), (...), ...}), (d4, ...), ...}. où e4 = 1, 4, 3, 4
-> Pour l'utilisation du livre, re fabriquer un arbre?
-> Faire une table de hachage pour simplifier (et accélérer) la recherche des positions répétées
-> Pour l'historique des positions, on peut le reset à chaque coup de pion ou capture
-> Pour les transpositions, on peut peut-être renvoyer au même indice de plateau fils...?
-> Pour chaque plateau, générer et stocker la representation simpliste du plateau? Pour ensuite pouvoir aider les fils à comparer?
-> ATTENTION aux conversions int et float dans les calculs d'évaluations...
-> Mettre les règles de parties nulles et mat en dehors de l'évaluation?
-> Ajouter les pièces protégées/attaquées lors de l'évaluation pour simplifier les calculs de l'IA
-> Carré du pion en finales
-> Ne comprend pas les finales de bases (du au fait qu'il répète les coups?)
-> Regarder dag chess?
-> Faire une map des cases attaquées (ça peut rendre plus rapide les tests d'échecs)
-> OpenAI propose un diviser pour reigner pour paralléliser GrogrosZero
-> Est-ce plus rapide de mettre des boucles simples plutôt que double? while plutôt que for?
-> Endgame : la force des pièces dépend du potentiel des pions (pièces seules = bof)
-> Faire des tables d'attaque (par exemple entre roi et dame, cavalier...)
-> Refaire toute l'architecture avec les get_moves(), pour que ça prenne tout en compte (sans le faire dans l'évaluation)
-> Calculer l'avancement de la partie au fur et à mesure de la partie (au lieu de le faire à chaque fois)
-> GrogrosZero ralentit beaucoup quand les variantes deviennent longues
-> ----> Faire une recherche spécialement de mat, où on prend plus en compte le matériel??
-> Au fil de la réflexion, retirer les coups pourris?? pour augmenter la capacité de stockage...
-> Mettre une variable globale pour la règle des 50 coups (pour la passer à moins, si besoin)
-> Rechercher large au début, puis serré après??
-> Changer un peu l'algo, pour que ça ne joue pas forcément le coup auquel il a le plus réflechi, mais un autre si il semble être meilleur (quand c'est mat, facile, mais sinon, comment savoir?)
-> Attaquer les faiblesses
-> Quand Grogros joue un coup auquel il n'avait pas pensé.. les évaluations déscendent pour les coups, 1 par 1... comment faire pour que tout descende en même temps?
-> L'éval statique en position symétrique sera toujours nulle ?? (modulo le trait du joueur)
-> Puissance de la paire de fou qui dépend du moment de la partie? Qui dépend si y'a encore les dames pour compenser?
-> Découper la foncion draw en plein de sous-fonctions?
-> Chercher ce qui prend le plus de temps dans la GUI
-> Recherche de Grogros : utiliser UCT
-> Tester Grogros sur les leçons stratégiques de chess.com
-> Mettre des static const un peu partout pour éviter les re définitions inutiles
-> Faut-il prendre en compte le nombre de noeuds dans un fils pour déterminer s'il faut regarder dedans?
-> Ordonnencement des coups : checks/captures/attacks
-> Dans les positions ou des pièces peuvent être capturées, Grogros évalue très mal (quiescence depth trop faible)
-> Retirer les espace dans les parsing de FEN (ou autres caractères non désirés)
-> Passer tous les commentaires en anglais et clean le code?
-> Evaluations en finales : un cavalier seul sans pions ni rien = nul
-> Mettre les noms de version sur le nom de Grogros
-> Utiliser toutes les améliorations/optimisations possibles sur VisualStudio
-> Mettre des uint_fast8_t partout
-> Negamax : utiliser les plateaux tout faits du buffer?
-> Mettre des variables globales partout !
-> Virer les attributs inutiles des plateaux
-> Faire une fonction qui regarde si un coup est légal
-> Regarder et virer toutes les conversions de int à float, et opérations entre int et floats
-> Position à tester : GrogrosZero vs Grogrosfish : 
	-> r1bqkb1r/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 : sans cavaliers
	-> rn1qk1nr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 : sans fous
	-> 1nbqkbn1/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w - - 0 1 : sans tours
	-> rnb1kbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 : sans dame
	-> rnbqkbnr/8/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 : sans pions
-> Faire des pre-calculs dans des constantes (genre des divisions), pour éviter de les faire à chaque fois
-> Mettre des flags pour les coups (capture, check, promotion -> caval possible??)
-> Descendre un peu le winrate par éval? réference : +1.00 = 50% de chances de gain
-> Quels paramètres sont meilleurs pour GrogrosZero? k_add? beta? quiescence_depth?
-> Utiliser std:sort pour trier les coups plus rapidement?
-> Alignement de pièces à finir (tour/roi, tour/dame...)
-> Taper les faiblesses (notions de pression)
-> Réduire la puissance des fous : un cavalier bien placé peut être tout aussi bon -> Outpost
-> Utiliser la map de contrôles pour les fonctions dans l'évaluation
-> Quand l'arbre est trop plein : élaguer les branches pourries, pour se concentrer sur les plus prometteuses
-> Faut-il vraiment regarder tous les coups d'une position avant de chercher plus loin??
-> Evaluer les finales différemment : faires des fonctions exprès pour (carré du pion, mat fou cavalier : il faut aller dans le bon coin)
-> Optimiser la mémoire de Grogros
-> Ajouter la nature de la position : ouverte, fermée... pour savoir à quel point les fous/cavaliers sont meilleurs, si y'a des chances de gain, si le développement des pièces compte beaucoup... l'espace aussi, la sécurité des rois...
-> Améliorer l'implémentation de l'activité des pièces : peuvent pas vraiment se déplacer sur des cases pourries...
-> Pour mieux évaluer la sécurité du roi, il faut regarder le surnombre de pièces sur le roi adverse (+2, c'est généralement mat)
-> Pourquoi dans les Caro-Kann, il fait Fd3 pour reprendre du pion c plutôt que de la dame?
-> Faire que Grogros reclique sur la fenêtre principale après jouer son coup sur chess.com pour reprendre la main? ou alors faire un focus sur la fenêtre?
-> Utiliser des static constexpr pour éviter des calculs redondants dans certaines fonctions
-> Il faut plus de g3 Fg2 -> revoir king safety?
-> Re utiliser la réflexion de la quiescence search pour la recherche normale
-> Faire evaluation.cpp? gui.cpp?
-> Comme pour le roi, garder en mémoire l'emplacement des pièces (utiliserait 256 bytes)
-> Afficher seulement les paramètres d'évaluation qui font sens? (par exemple king opposition seulement lorsque c'est une finale de pions)
-> Tout foutre dans la classe GUI? les variables globales et fonctions globales en particulier -> par exemple eval_components
-> Adapter les fonctions aux coups (make_move(Move)...)
-> Faire des méthodes utiles pour les coups
-> Verifier que quiescence depth 0 est aussi rapide qu'une simple évaluation
-> Flags pour les coups
-> Rendre from_fen plus tolérant
-> Améliorer l'évaluation en faisant jouer contre Leela, et regarder ce que Grogros évalue mal
-> Eviter les accès à _moves[i] trop souvent? -> copier le coup?
-> IMPORTANT : refaire toutes les recherches de mat, et leur stockages
-> Faire le threading !
-> Faire un king_centralization pour l'endgame?
-> Voir comment gérer les positions qui sont mal évaluées par GrogrosZero
-> Implementer les policy pour les coups (pour regarder des coups plus que d'autres)
-> Pion de moins en finale de pions est quasi toujours perdant
-> Ajouter la pièce dans le coup (et l'utiliser)
-> Revoir les undo, et les faire rapides pour les utiliser au lieu de copier les plateaux
-> Faire des tests de vitesse pour l'évaluation
-> Evaluation endgame très mauvaise
-> Quand une position est surestimée, Grogros va jouer des coups pour retarder l'échéance, mais qui peuvent pourrir la position encore plus
-> Quand une position est sous-estimée, Grogros va jouer un coup qui parait bien et réfléchir beaucoup dessus, même si d'autres variations peuvent être meilleures
-> Revoir negamax
-> Utiliser sort c++ pour trier les coups
-> Rajouter les coups du quiescence dans monte-carlo, et inversement... -> mettre le quiescence dans MCTS?
-> Remettre la dame dans la mobilité des pièces et l'activité? pour que ça développe la dame aussi? Sinon, ça évalue mal ces positions: r1b1kbnr/ppqp1ppp/2n1p3/8/3NP3/2N5/PPP2PPP/R1BQKB1R w KQkq - 1 6 
-> r1bqkb1r/ppp2ppp/2n1p3/8/3PP3/2P5/P4PPP/R1BQKBNR w KQkq - 0 7 : piece_mobility seulement +0.18? c'est un bug?
-> Dans la recherche de grogros_zero, regarder en priorité les coups forts et peu regardés
-> Detection plus rapide d'échecs et mat
-> Regarder où on fait des accès mémoire fréquent et faire des copies locales pour aller plus vite?
-> Refaire la partie sur attacks and defenses... pour que ça soit plus précis.. là si on tape un pion protégé, ça fait un bonus...
-> Lorsqu'une position est mal évaluée, ajouter une constante de correction d'évaluation pour toutes les positions résultantes (ou jusqu'à ce que l'évaluation soit bonne)
-> King safety, safe checks: FIXME -> ça prend pas en compte les échecs à la découverte, ni les échecs par clouage
-> Faire quelques playoff jusqu'au bout pour avoir une idée de la nature de la position??
-> Fix pawn push threat : quand la case est controllée...
-> Passer la quiescence à depth 8 ou +? sinon y'a encore des positions mal évaluées... à voir si on peut réutiliser les noeuds de la quiescence pour la recherche normale
-> Créer une classe 'arbre' pour les recherches de GrogrosZero?
-> 6k1/4pp1p/P2p2p1/8/4P3/1P6/5PPP/6K1 b - - 0 26 : il faut améliorer king proximity avec les pions passés: le roi est clairement pas dans le carré
-> Constructeur de coups à partir d'un string
-> Passer les fonctions d'évaluation dans evaluation.cpp
-> Changer tous les play_move(i) en play_move(move)
-> Il faut vider l'historique des variantes quand on change de position... faire une méthode pour reset?
-> Mettre plus de choses dans GUI.cpp
-> Refaire le tri des flèches
-> Refaire toutes la fonction de dessin de la GUI (notamment pour clarifier les sélections.. puis faire les pre-moves..., draw arrow...)
-> Rajouter 'overwrite' en paramètre de la génération de coups
-> Ne pas jouer le coup quand un autre est en train de devenir meilleur?
-> Changer l'activité des pièces? -> Faire comme pour les tours, regarder en fonctions des pions qu'il y a devant?
-> Punir la perte des droits de roques -> si le roi est au milieu
-> Structure de pions (connected -> -?)
-> King safety en endgame -> wtf parfois
-> 7k/4r3/5pBP/p1n5/P6P/1P2PK2/5P2/8 b - - 3 51 : king safety??????
-> Rajouter des comtempt: valeur qui dépend de l'adversaire, et qui définit à quel point tu acceptes les nulles (et tente des pièges?)
-> Faire une structure pour la recherche de MonteCarlo (arbre avec noeuds)
-> Bishop pawns: retirer une part de la pénalité quand le fou est devant et protégé par un de ses pions?
-> FIXME : pour l'activité des tours, parfois Grogros va faire un Th7 pour se déroquer (car il pense que sa tour ne sera plus bloquée). Il faut fix à tout prix
-> Souvent, Grogros dépasse le centre pour rien, et ça crée des faiblesses et ne sert à rien (il faudrait mieux se développer à la place...). Contre les double fianchetto, ce genre d'erreur est fatal
-> Utiliser des émoticones pour les pièces d'échec? \u2656xb5 plutôt que Rxb5
-> Faire des plus petites allocations de buffer pour aller plus vite? et re allouer de la mémoire si on a rempli le buffer?
-> Faire un truc sur la mobilité totale des pièces? qui ressemble à un logarithme? -> t'as pas de coups -> eval: -inf, t'as k coups -> eval: 0, et ça augmente en log
-> Utiliser Texel tuner pour rectifier l'évaluation?
-> Mettre les fous sur les diagonales ouvertes (voir comme on fait pour les colonnes des tours)
-> 2b3k1/4bp2/3p1n1p/PP4p1/4P1P1/3BBP2/5K1P/8 w - - 1 36 : les pions connectés fonctionnent bien?
-> Heuristique pour à quel point le roi est proche de roquer?
-> Heuristique d'ouverture de la position -> draw ou non
-> Grogros peut améliorer sa gestion du temps en en prenant un peu plus en fin de partie s'il lui en reste beaucoup. Prendre en compte aussi le temps de l'adversaire?
-> Rajouter les pions passés soutenus par une tour derrière
-> En finale contre fou, mettre les pions sur la couleur opposée au fou
-> Parfois il fait Fb2 dans le pion c3
-> Remettre toutes les conditions pour determiner le temps pour jouer dans la fonction prévue pour
-> Beaucoup de choses peuvent être factorisées dans le main_gui (get_orientation() par exemple)
-> BUG: quand on lance les threads de Grogros lorsque le buffer est plein, ça plante
-> BUG: parfois grogros crash... à cause d'avoir retiré le plateau principal du buffer?
-> Comment faire pour connaitre l'origine d'un crash?
-> Il faut des classes pour l'évaluation (mettre toutes les fonctions dedans), pour l'algo de GrogrosZero (dont un arbre de recherche...)
-> Weak squares: faire de manière plus progressive? (un pion qui contrôle c'est ok, deux c'est mieux...)
-> get_safe_checks() -> prend 90% du temps de l'évaluation...
-> BUG: parfois après une repetition 1 fois, Grogros choisit un coup complètement pourri et en est sûr (perdant) : ça arrive encore?
-> Pour tester les versions de grogros, faudrait que je fasse une fonction qui le confronte à un certain nombre de puzzles/evaluations et voir combien il en réussi pour lui donner un score. (utiliser ça aussi pour entraîner les réseaux de neurones?)
-> BUG: parfois, grogros stoppe le temps en pleine partie (il pense que la partie est finie??)
-> Pour get_zobrist _key, regarder si on ne le fait pas trop souvent
-> Dans les finales, il faut évaluer comment on peut avancer ou non... sinon il voit pas quand y'a des égalités...
-> Gros problème de compréhension: r6r/p1p1kp1p/3p3q/2p1P3/6Q1/3B4/PP3P1P/2R2RK1 w - - 1 20 il voit pas la menace des noirs sur la dame et le roi
-> 2r2k1r/pp2npp1/3p1n2/q3p2p/4P3/2PB1Q2/P1PB1PPP/R4RK1 b - - 1 16 : ici faut faire quelque chose pour que Th7 n'augmente pas l'activité de la tour d'autant. (pour le moment c'est à cause de la condition sur la tour bloquée par le roi dans le roque)
-> 8/6B1/7p/7b/p7/1k2KPP1/1P6/8 w - - 0 39 : Grogros devrait savoir comment gagner ça quand-même (il a raté...)
-> Il est relou avec ses Th7 pour se déroquer...
-> Définir des concepts positionnels actifs et passifs (court terme et long terme), puis leur donner une valeur en fonction de la nature de la position (position ouvrte -> actif, fermée -> passif)
-> Les pions faibles le sont encore plus lorsqu'ils sont bloqués par des pions adverses


----- Interface utilisateur -----

-> Faire un readme pour les contrôles
-> Amélioration des sons (en faire des maison?)
-> Nouveau sons/images
-> Dans le negamax, renvoyer le coup à chaque fois, pour noter la ligne que l'ordi regarde?
-> Faire des boutons pour faire des actions (ex copier ou coller le FEN/PGN, activer l'IA ou la changer...)
-> Options : désactivation son, ...
-> Chargement FEN -> "auto-complétion" si le FEN est incorrect
-> Régler le clic (quand IA va jouer), qui affiche mal la pièce (grogrosfish)
-> Modification de l'incrément dans la GUI
-> Interface qui ne freeze plus quand l'IA réfléchit -> Paralléliser
-> Sons pour le temps
-> Premettre de modifier les paramètres de recherche de l'IA : beta, k_add... (d'une meilleure manière)
-> Musique de fond? (désactivable)
-> Ajouter un éditeur de positions (ajouter/supprimer les pièces)
-> Utiliser 1 thread pour gérer l'affichage tout seul
-> Undo doit retirer le coup du PGN aussi
-> Afficher les textes avec des différentes couleurs pour que ça soit plus facile à lire
-> Défiler la variante quand on met la souris dessus
-> Montrer sur l'échiquier quand la position est mate (ou pate, ou autre condition de fin de partie)
-> Faire un reconnaisseur de position automatique
-> Unload les images, textures etc... pour vider la RAM?
-> Pouvoir changer les paramètres de l'IA dans l'UI
-> Ajouter des options/menus
-> Pouvoir sauvegarder les parties entières dans un fichier (qui s'incrémente), pour garder une trace de toutes les parties jouées
-> Analyses de MC : montrer le chemin qui mène à la meilleure éval, puis celle qui mène au jeu qui va être joué
-> Pouvoir grab le slider, ou cliquer pour changer sa place
-> Faire des batailles entre différents paramètres d'évaluation pour voir la meilleure config -> Retour des batailles de NN?
-> Importation depuis un PGN
-> Afficher sur le PGN la reflexion de GrogrosZero
-> Pouvoir changer le nombre de noeuds de l'IA dans la GUI... ou la profondeur de Grogrosfish
-> Parfois l'utilisation des réseaux de neurones bug
-> Nd2f3 -> Ndf3? pas facile à faire
-> Ajouter la possibilité de faire plusieurs pre-move
-> Faire du smooth sur la barre d'évaluation
-> Faire un graphe d'éval en fin de partie?
-> Mettre des + sur les flèches (comme il y'a des -...)?
-> Faire un fonction pour tranformer une éval en son texte (mat ou non)
-> Certains calculs sont peut-être en double dans l'affichage
-> Echelle logarithmique pour la barre d'éval?
-> Gestion du temps bizarre? Car le temps affiché par GrogrosZero n'est pas vraiment le vrai (ni sa vitesse)
-> Clean l'implémentation de la GUI -> Faire des nouvelles fonctions pour tout simplifier
-> Faire un vecteur pour les pre moves et les flèches
-> Fins de parties : message + son
-> Dans une position que GrogrosZero sous-évalue, jouer le coup auquel il a le plus réflechi. dans le cas contraire, jouer le coup avec la meilleure éval
-> Barre d'éval : barre pour l'évaluation du coup le plus recherché par l'IA? ou éval du "meilleur coup"?
-> Mettre le screenshot dans le presse-papier?
-> Faire un truc pour montrer la menace (changer le trait du joueur)
-> Pouvoir éditer les positions
-> PARALLELISER L'AFFICHAGE !! ça lag beaucoup trop !!!
-> Refaire les pre-moves depuis zéro (et ajouter la possibilité d'en faire plusieurs)
-> Trop de flèches = crash
-> Lignes de bézier et cercles pas très beaux
-> Nouveaux bruits de pièces plus "soft" + bruit d'ambiance?
-> Montrer toute la variante calculée avec des flèches (d'une couleur spéciale)
-> Thread : bug... parfois les coups joués ne sont pas les bons
-> Re foncer le noir des pièces?
-> Pourquoi dans certaines variantes, l'éval ne s'affiche pas à la fin??
-> Dans les .h, remettre les noms des arguments?
-> Rajouter des pre-moves pour Grogros si c'est un coup forcé en face
-> Pourquoi c'est lent de changer la taille de la GUI?
-> Pour la barre d'éval, on utiise le winrate?
-> Faire des maps pour afficher les paramètres d'évaluation (genre afficher les cases controllées, avec une couleur plus ou moins prononcée...)
-> Pouvoir facilement changer les paramètres de Grogros (quiescence depth, beta, k_add, paramètres d'évaluation...)
-> Pouvoir changer l'affichage de la GUI (winrate/eval)
-> Faire des menus
-> Désélectionner les pièces lors d'un chargement de position
-> Utiliser des checkCollision de raylib pour la GUI
-> Afficher l'incrément de temps sur la GUI, et pouvoir le modifier
-> O-O+ dans les move label à prendre en compte
-> Revoir les update du temps quand on le change pendant que ça joue
-> Afficher des traits autour du plateau chess.com?
-> Affichage de la réflexion de Grogros sur le PGN : {N: 10.29% of 544}
-> Revoir le compare moves (sinon ça affiche pas toujours le meilleur coup au dessus)
-> Adapter nodes_per_frame en fonction du temps de réflexion de GrogrosZero (tant que la parallélisation n'est pas faite)
-> Montrer l'incrément sur la GUI
-> Afficher le titre et l'elo des joueurs sur la GUI
-> Revoir le tri des coups pour les flèches de GrogrosZero, car parfois ça ne se trie pas bien
-> Afficher différement la pièce sélectionnée (et au dessus des autres pièces)
-> Faire des animations de Grogros qui bouge les pièces
-> Quand on joue un coup (en appuyant sur p ou autre), il faut désélectionner la pièce
-> Refaire la réflexion de GrogrosZero: quand il y a beaucoup d'incertitude dans l'éval, regarder large. Sinon, regarder profond
-> Mobilité verticale ~= activité pour les tours?
-> Vérifier qu'il n'y a pas d'int overflow dans la sélection des coups (softmax...)
-> rnb2bnr/pppp1k1p/5q2/8/5p2/2N1BQ2/PPP3PP/R4RK1 b - - 3 11 : il évalue mal, et teste les coups 1 par 1 et se rend compte que ça va pas... beaucoup trop lent à ré évaluer la position correctement.
-> Changer l'affichage du plateau en fonction de l'arbre de jeu, et le fils principal (surligner le coup)
-> Barre d'éval : afficher l'éval du coup le plus recherché par l'IA? ou éval du "meilleur coup"?
-> Time management: faire en fonction de la différence entre le meilleur coup et les autres pour jouer plus vite? Debug pour voir si tout fonctionne bien
-> Afficher l'endroit où on en est dans la variante, pouvoir cliquer dessus, changer les variantes
-> Dé-surligner le coup quand on navigue dans les coups
-> From_fen -> reset l'arbre
-> Surligner le coup principal de la variante
-> Parfois des positions buggent quand on navigue.. ça affiche des pièces en énorme (à cause de la réflexion de Grogros qui a supprimé le coup?)
-> Remettre les chronos dans le PGN généré par l'arbre (et les noeuds, et d'autres notations?)
-> Garder les réflexions de GrogrosZero quand on navigue dans les coups
-> Passer une variante en principale
-> Montrer quand une ligne d'analyse est montante ou descendante
-> Parallélisation: faut que les quiescence nodes augmentent aussi
-> Quand on navigue dans la partie, jouer les son
-> Afficher en vert, orange ou rouge les forces et faiblesses de la positions?
-> Afficher à quel coup de la variante on est
-> Ré-afficher un peu mieux les variantes et avec plus de détails (profondeur...)
-> Affichage du temps dans le PGN
-> Mettre des flèches pour indiquer les coups de la variante principale?
-> Inclure la proba de draw dans la barre d'éval


----- Grosses implémentations à faire -----

-> Table de transposition
-> Bitboards
-> Réseaux de neurones: tester des matches avec 0 réflexion, seulement le coup proposé par le réseau?
-> Parallélisation (possible sur le GPU?)
-> Policy pour les coups
-> "Killer moves", ou gestion des menaces
-> Arbres de variations / Chargement de PGN
-> Livre d'ouvertures
-> Beaucoup de vérifs à faire dans les fonctions principales (make_move, grogros_zero, get_moves...)
-> Buffer de coups pour éviter de les stocker dans les plateaux


----- En cours -----

-> BUGS:
2k1r1nr/pb5p/1pp1p3/5pB1/8/P4B2/1qP1QPPP/3R1RK1 w - - 0 18 : il a vu que Dc4 était meilleur, puis a joué Td6.........
r1bk3r/pp1nq2p/4p3/3pP2Q/3p4/1N1B4/P5PP/R4RK1 w - - 7 22 : il faut jouer Tf7!!
-> 6k1/ppp2ppp/2n5/5b2/8/P1QBqNbP/1P1N2P1/R4K1R w - - 0 18 : pourquoi +280 en attaque
-> r1bq1r2/pppp1ppk/2n1p3/3nP1b1/3P3P/8/PPP2PP1/RNBQK2R w KQ - 0 9 : il regarde pas hxg5???
-> r1bq1rk1/2p1ppbp/pn1p3B/1p5p/3PP3/2N2P2/PPPQ2P1/2KR1BN1 w - - 0 12 : Dg5 c'est mat en 2 imparable.. il met combien de temps à le voir?...
-> r1bq1rk1/2p1pp1p/pn1p1npQ/1p6/3PP1P1/2N2P2/PPP5/2KR1BNR w - - 2 4 : e5??
-> rn2k1nr/ppp1ppbp/6p1/8/3Pq1b1/2P1BN1P/PP3PP1/RN1QKB1R b KQkq - 0 7 : il regarde pas Fxf3??
-> 2r3k1/6p1/8/5p1p/4nP2/R1BRP3/2P1K2P/1r6 b - - 3 39 : il voit pas Th1+?
-> 2r3k1/6p1/8/5p1p/4nP2/R1BRPK2/2P4P/7r b - - 5 40 : Txh2??
-> Après une répétition, Grogros ne joue plus
-> Revoir les promotions de variantes etc...
-> Parfois quand on joue 2 fois un même coup dans des variantes différentes, ils ont le même parent... du coup quand on revient en arrière, ça va au mauvais endroit
-> 2r3k1/pp1n3p/3P2pB/2pr1q2/P2nN3/1P4Q1/R1P2PPP/4R1K1 b - - 8 26 : ici après Ce2+ Txe2 Te1+, la quiescence s'arrête alors que le joueur est en échec
-> Parfois il ne joue pas le coup qu'il pense être le meilleur? r2qk1nr/ppp1pppp/2n5/8/3Pp1Q1/2P5/PP3PPP/R1B1KB1R b KQkq - 0 4 : ici il a joué Rf8 plutôt que Cf6... (après avoir vu que Cf6 était meilleur)
-> Quand y'a plusieurs eval de mats, il joue lentement, car les evals sont relativement proches?
-> r1b1k1r1/pp1npp1p/1q4p1/2p5/4B3/2P1BN2/Pb1Q1PPP/3R1RK1 w q - 0 16 : juste Tb1??
-> Auparavant, il prenait plus de temps pour réflechir quand les positions étaient complexes (car il jouait en fonction du nombre de noeuds "quiet")
-> 2Bk1b1r/1p4pp/p1q2p2/3pn3/3B4/7Q/PP1N1PPP/3bR1K1 w - - 1 21 : Fe6 quand y'a pas les échecs de regardés? Txd1 sinon?
-> rnbqk1nr/ppp2ppp/3b4/8/3P4/8/PPP1P1PP/RNBQKBNR b KQkq - 0 4 : Dh4+??
-> 8/q1p2kp1/3bp2p/4p3/1pP1P3/rP2RNPP/2Q2PK1/8 w - - 3 31 : Ta2 arrive et c'est foutu si laissé!
-> Parfois y'a des game reset...
-> 3r1rk1/1p2p1b1/8/p1pp1p2/P2P4/1PP1P1R1/4Q3/R3KN1q w Q - 0 30 : faut roquer!!!!! -> vis à vis roi/dame => tour/dame

URGENT ***
-> get_safe_check_value() : hypeeeer lent!!!
-> Vérifier l'algo... à chaque fois y'a des coups qu'il regarde pas, sauf quand on clique dessus, il voit que c'est le meilleur coup...
-> Elargir la zone d'attaque défense du roi? pion en e5 participe à l'attaque.. le fou c1 aussi...
-> Ajout tours liées (déjà fait dans attacks/defenses?)
-> 5r2/2p3pk/pp1b2rp/3Rpq2/2P2P2/1P2B1P1/6QP/3R2K1 b - - 0 27 : beaucoup de choses à revoir dans king safety.. il faut mieux combiner les paramètres... ici les noirs sont gagnants
-> rnbr2k1/pp4q1/2pb4/6NQ/7R/6P1/PPP2P1P/2KR4 b - - 0 20 : pourquoi A = +495 sur le roi blanc???
-> Régler les bugs de quiescence
-> 8/5pk1/6p1/6P1/4K3/PB2P1rp/1PP2r2/3R4 b - - 1 37 : passed pawn -> pourquoi il perd de la valeur quand on le pousse vers h2???
-> 8/2k5/7R/4K3/8/8/8/8 w - - 14 8 : CRASH!! : y'a des gros bugs... ça met M3, M4, 0... et ça oscille
-> Dans quiescence à depth 0, il est pas censé passer plusieurs fois dedans pour un même noeud.. si?
-> En fait si, mais on peut avoir des quiescence à depth -1... ça pose problème?
-> 4k3/7R/3K4/8/8/8/8/8 b - - 23 12 : ????
-> 4b3/1k6/3K4/1p4N1/5P2/2P5/1P6/8 w - - 1 56 : crash aussi quand on joue un peu
-> 5k2/5p2/6p1/R5Pp/7P/P3PBK1/1r6/5r2 w - - 0 31 : ??? les noirs sont gagnants....
-> 5k2/R4p2/2B3p1/6Pp/7P/P3P1K1/1PPr4/3r4 w - - 1 27 : plutôt égal
-> Il donne des pions beaucoup trop facilement...
-> r1bq1b1r/ppp2kpp/5n2/n7/3Bp3/8/PPPNNPPP/R2Q1RK1 b - - 2 9 : -_- le roi noir n'a pas de soucis là...
-> r2q4/p1p2k1p/3b4/1p3p2/2P3b1/2Q2N2/P1P1r1PP/3R1R1K w - - 0 19 : c5??????????????????????
-> 8/2p3p1/2P3P1/3Nb3/8/1k6/8/q1K5 w - - 0 63 : pareil aussi parfois
-> Evaluer la nature de la position (ouverte/fermée), car ça change tout sur s'il faut jouer actif ou positionnel...
-> Refaire un nouveau pick random move plus simple?
-> 5b1r/Npk3pp/pn2b2n/2p1P3/8/3QBN2/P4PPP/5K2 b - - 0 20 : combien de temps il met à voir Fc4?? -> la quiescence ne semble pas fonctionner du tout...
-> rnb1kbnr/ppp1pppp/2q5/8/8/2N5/PPPP1PPP/R1BQKBNR w KQkq - 2 4 : pareil, Fb5 devrait être trouvé instantanément!!
-> parfois ça re-explore un coup non fully explored avant de regarder les non-explorés...
-> 1Q6/8/K7/8/8/4Q3/2k5/8 w - - 3 74 : il crash??
-> 8/2k5/3p4/p2P1p2/P2P1P2/8/3K4/8 w - - 10 6 : il crash aussi?
-> Transpositions!! on a des overflows etc.. des trucs louches se produisent
-> A REGLER: *** Si y'a un problème de nombre de noeuds, c'est que lorsqu'on calcule dans une variante transposée, un seul des parents est mis à jour ***
-> r1b3rk/pp1nbp1q/2p1p3/8/2BP4/2N1PNR1/PP3P1P/2K2Q2 w - - 1 13 : Th3!! c'est fini... (à cause de la quiescence trop longue il voit pas le coup, car tout n'est pas encore exploré?)
URGENT ***

-> URGENT: faut-il garder le beta cut-off si on est en échec??? alpha aussi??
-> Voir s'il faut moduler la profondeur de la quiescence en fonction de l'importance de la branche
-> Il faut revoir la quiescence pour voir si c'est correct...
-> q_depth plus petit avec des cas d'extensions?
-> revoir les autorisations de standpat?
-> positions_history à mettre dans exploration plutôt que board

-> EVAL: 
-> IMPORTANT: Alignements à terminer absolument... implémenter les fonctions d'évaluations étant en TODO
-> r1bq1r1k/1pp3p1/1n2pb1p/8/pP1P3P/P2B1NR1/2QB1PP1/R3K3 w Q - 2 19 : +2 à cause d'un overload sur h7, alors que ça menace rien...
-> Réduire l'attaque lorsque négative? Sinon ça donne un trop gros bonus de défense, et il peut pousser des pions devant son roi pour rien
-> Rajouter les unsafe checks: r3r1k1/p1p2ppp/2p5/2b1P3/2Pq2b1/2N3Q1/PP3nPP/R1B1KBR1 w Q - 1 15 ici ça donnerait beaucoup de poids à l'attaque des noirs
-> Combiner la puissance d'attaque avec le manque de protection? et les autres afaiblissements?
-> Combiner pièce isolée avec pièce enfermée / attaquée?.. sinon il donne des pions en 1
-> r1bq1rk1/1ppnbppp/4p3/4P3/pPBP3P/P4N2/2QB1PP1/R3K2R b KQ - 0 14 : ici, il faut regarder le nombre de pièces en attaque pour les blancs: elles participent presque toutes! (même le pion e5)
-> r1bq1rk1/1pp1bpp1/1n2p2p/4P3/pP1P3P/P2B1N2/2QB1PP1/R3K2R w KQ - 0 16 : Th3 très fort, pour ramener une autre pièce dans l'attaque
-> r2q1r1k/1ppbbpp1/1n2p2p/4P3/pP1P3P/P2B1NR1/2QB1PP1/R3K3 w Q - 4 18 : Fxh6!! gagne déjà
-> r1bq1rk1/1pp3p1/1n3b1B/4p3/pP1P2R1/P2B1N2/2Q2PP1/R3K3 w Q - 0 21 : Txg7!! gagne (il faut un peu de calcul quand-même)
-> Redonner de la valeur aux fous. Ils sont meilleurs que les cavaliers en général (notamment quand on a la paire de fous)
-> 8/p4k1p/6r1/n7/8/1PP3P1/R4PKP/8 b - - 2 39 : weak squares +160??... Il faut vraiment améliorer ça... quand y'a plus de pions, il voit des cases faibles partout...
-> Pour évaluer les finales etc.., il faut un winnable white, et un winnable black... Tour Cavalier vs Tour = nulle
-> Pions isolés, pions arriérés: malus si sur colonne ouverte
-> Pour les pièces isolées, accentuer le malus si elles sont enfermées/attaquées
-> Re-évaluer les pièces en fonction du type de position (colonnes / diagonales ouvertes / fermées, pions passés...)
-> Organiser l'affichage de l'évaluation par catégorie. L'afficher en plus fin/petit pour qu'on en voit plus. Montrer aussi les facteurs multiplicatifs
-> 2rqkb1r/pp3p2/2n1p3/3pPnpp/3P4/3QB1PP/PP1N1P1N/R4RK1 b k - 0 14 : pas Th7 stp...
-> 3rkbnr/pQ2pppp/4q3/2p5/3n4/6PP/PPPP1PB1/RNB2K1R w k - 1 10 : ici c'est les blancs qui sont gagnants...

-> r2q4/pp4kp/2p1Qrp1/3pB3/3P4/8/PPP3PP/R5K1 w - - 0 20 : met 4 ans à voir que Tf1 gagne alors que c'est évident... la quiescence prend trop de temps alors il regarde pas tous les coups et reste sur le standpat
-> 1Q6/8/K7/8/8/4Q3/2k5/8 w - - 3 74 : y'a mat en 1, qu'il arrête de regarder les coups pourris à 90%!!
-> r7/pp5k/2p2B2/3p2Qp/3P4/8/PPP3PP/6K1 w - - 1 25 : pareil
-> A cause de la quiescence trop longue qui regarde les coups complexes à fond...

-> Améliorer le PGN (temps, noeuds, éval...)
-> Améliorer le visuel des pièces uft8

-> FAUT METTRE DES POINTEURS PARTOUT AU LIEU DE COPIER LES OBJETTTTTTSSS !! (exploration.h, gui?)

-> Regarder les TODO/FIXME dans exploration.cpp
-> Alpha-beta pruning pour la quiescence search à fix...
-> Regarder les fins de variantes pour voir si ça fonctionne
-> r1b1r1k1/pp3pbp/6p1/qB1p4/3P2n1/1Q3NP1/PP1N1P1P/2R2RK1 b - - 2 17 : là c'est seul coup, il faut jouer !!
-> 8/8/2q5/6n1/5k2/1K4p1/8/8 w - - 0 90 : il joue plus quand il est mat?? il passe dans le négatif...
-> S'il est si lent c'est qu'à cause de la nouvelle quiescence, il y a des noeuds dans toutes les branches, ce qui fait penser à Grogros qu'il hésite sur les coups...
-> 6k1/5ppp/5n2/1Q6/1P2p1b1/4b2P/1B1rNqP1/2K2B1R b - - 1 22 : que 10% sur le mat??


-> rnbqkbnr/pppp1ppp/8/4p3/6P1/5P2/PPPPP2P/RNBQKBNR b KQkq - 0 2 : ici c'est #1, faut au moins que 90% de la réflexion soit sur le mat

-> il faut un nouvel algo, ça fonctionne juste pas...

-> choix des noeuds: à faire en fonction des noeuds complets seulement?

-> Algo catastrophique... il paraît juste plus lent qu'avant, il voit rien

-> TESTING: Faire une fonction pour tester les IAs: problèmes tactiques, stratégiques, finales, ouvertures... avec différents temps de réflexion (1s, 3s, 10s par exemple)
-> Fonction de test d'évaluation: comparer les évals de Grogros avec celles de Leela par exemple puis fine-tuner. Résultat final: correlation entre les évals de Grogros et les évals de Leela
-> Utiliser ça pour entraîner les réseaux de neurones (au lieu de jouer contre d'autres réseaux? combiner les deux?)

-> Utiliser les noms des pièces plutôt que 0, 1, 2, 3... Utiliser Array plutôt que le faire à la main. Faire une structure pour stocker les coups plutôt qu'un tableau lourd?

-> Simplifier le softmax: delta entre le meilleur coup et l'actuel, et voir en fonction du pourcentage de réflexion déjà fait

---------
-> Pour le softmax, faut-il un gradient absolu ou relatif? pour le moment il y a la même différence entre -100 et +100 qu'entre +1800 et +2000? pas optimal...
-> Peut-on fusionner _tested_moves et _current_moves?
-> Il faut reset la table de transposition après chaque coup? sinon y'aura des positions obselettes (et potentiellement avec des indices buffer faux)
-> Réduire le temps de l'évaluation de Grogros (voir king_safety, et implémenter l'évaluation incrémentale)
-> Utiliser une mini clé de Zobrist pour les répétitions (car il y a peu de chances de collisions?) -> clé de 16 bits?
-> Table de transposition
-> Promotion de variantes: il faut repasser sur la variante principale au moment de la promotion
-> Promotions de variantes -> il faut promouvoir toute la branche depuis le début, pas juste le dernier coup (+ le FIXME -> il faut sélectionner le bon noeud après la promotion)
-> Pawn storm / Pawn shield (rajout des colonnes/diagonales ouvertes etc...) / Pions arriérés / Fix king safety / Pieces alignement (à finir)
-> Quiescence nodes qui augmente aussi avec les threads
-> Temps affiché = vrai temps
-> Delta pruning (quiessence search)


----- Réseaux de neurones -----

-> Faut t-il de la symétrie dans le réseau de neurone? (car sinon il évalue pas de la même manière les blancs et les noirs)
-> Comment le faire apprendre?
-> Parties contre lui-même
-> Algorithme génétique: on détruit les plus faibles, et on fait des mutations sur les plus forts
-> Bonus et malus pendant les parties, lorsqu'il a mal évalué une position
-> Apprentissage à partir des fins de partie, puis on remonte
-> Reinforcement learning
-> Prendre en compte d'autres paramètres que les pièces (trait, roques...)
-> Y'a peu de valeurs négatives dans les évals, est-ce normal?