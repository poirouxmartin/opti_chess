----- Documentation pour la suite -----

https://cs229.stanford.edu/proj2012/DeSa-ClassifyingChessPositions.pdf
https://www.wikiwand.com/en/Negamax
https://thesai.org/Downloads/Volume5No5/Paper_10-A_Comparative_Study_of_Game_Tree_Searching_Methods.pdf
https://www.chessprogramming.org/Evaluation_of_Pieces
https://www.chessprogramming.org/Evaluation
https://www.cs.cornell.edu/boom/2004sp/ProjectArch/Chess/algorithms.html#board
https://www.chessprogramming.org/Main_Page
https://towardsdatascience.com/building-a-chess-ai-that-learns-from-experience-5cff953b6784
https://arxiv.org/pdf/1711.08337.pdf
https://stackoverflow.com/questions/40137240/training-of-chess-evaluation-function
https://arxiv.org/pdf/2007.02130.pdf
https://www.chessprogramming.org/Move_Generation
https://www.chessprogramming.org/Checkmate
https://www.chessprogramming.org/Bishop_versus_Knight#WinningPercantages
https://www.chessprogramming.org/Sensor_Chess#MoveGeneration
https://hxim.github.io/Stockfish-Evaluation-Guide/
https://www.chessprogramming.org/Repetitions
https://en.wikipedia.org/wiki/Threefold_repetition
https://www.chessprogramming.org/Opening_Book
https://www.chessprogramming.org/Pawn_Structure
https://www.chessprogramming.org/Time_Management
https://www.chessprogramming.org/Encoding_Moves#MoveIndex
https://lichess.org/page/accuracy
http://www.talkchess.com/forum3/viewtopic.php?f=2&t=68311&start=19
https://www.chessprogramming.org/UCT
https://www.codeproject.com/Articles/5313417/Worlds-Fastest-Bitboard-Chess-Movegenerator


----- Jeu -----

-> Promotions (de tous types plutôt que seulement dame)
-> Rajouter des tests de validité de FEN
-> Répétition de coups
-> Pouvoir naviguer dans l'historique des coups


----- Structure globale du projet -----

-> Séparer les fonctions du fichier board dans d'autres fichiers (GUI, IA...)
-> Faire du ménage dans les fonctions
-> Faire une classe pour les IA?


----- Optimisations à implémenter -----

-> Regarder quel compilateur est le plus rapide/opti
-> Algo Negamax -> copies des tableaux -> undo moves? ---> finalement plus lent?
-> Transposition tables
-> Algorithme MTD(f) <-> alphabeta with memory algorithm
-> stoi et to_string très lents?
-> Ajout de variables globales plutôt que les re définir lors des appels de fonction (valeur des pièces, positionnement...)
-> Parallélisation -> std::for_each avec policy parallel?
-> Au lieu de calculer l'évaluation à chaque coup, l'imcrémenter en fonction du coup
-> Dans le negamax, si y'a un mat, ne plus regarder les autres coups?
-> Optimiser le sort moves - l'améliorer (et l'évaluation?)
-> Remplacer des if par des &&
-> Vérifier que toutes les fonctions sont optimisées
-> Faire le triage des coups grâce aux itérations précédentes?
-> Fonction pour stocker facilement un noeud, ou savoir s'il est similaire à un autre? -> transposition tables
-> Incrémenter le game_over à chaque coup joué plutôt que de le regarder à chaque fois
-> Regarder si l'implémentation des échecs rend les calculs plus rapides
-> Ne plus jouer les échecs?
-> Copie des plateaux : tout copier? ou seulement quelques informations importantes?
-> Liste des coups légaux, et une autre liste pour les coups pseudo-légaux... pour éviter de les recalculer à chaque fois...
-> Utiliser les threads.. voir cours ProgrammationConcurrente
-> Checker SIMD code (pour optimiser)
-> Calcul de distance à un bord : simplement faire une matrice globale des distance pour chaque case, et regarder dedans -> https://www.chessprogramming.org/Center_Manhattan-Distance
-> Faut-il stocker les positions de certaines pièces (les rois par exemple), pour accélérer certains calculs?
-> Regarder dans les copies de tableau si on peut ne pas copier des choses, ou en copier plus...
-> Précalculer pas mal de choses si possible
-> Incrémentation de l'évaluation


----- Intelligences artificielles -----

--- Nouveaux algorithmes ---

-> Grogrofish_iterative_depth -
-> Changer Grogrosfish : depth -> temps (--> moteur d'analyse)
-> Faire une profodeur -> trier les coups du meilleur au pire, puis continuer la recherche plus loin
-> Agent_new = Agent_old++ -
-> Faire un agent qui gagne toujours contre un autre : regarde tous les coups, et joue pour chacun la partie jusqu'au bout en utilisant agent_old -> puis joue les coups qui gagnent
-> RE : multi_agents

--- Améliorations ---

- EVALUATION -
-> A ajouter :
	- Sécurité du roi (TRES IMPORTANT !) --> A améliorer: lignes ouvertes et colonnes ouvertes proches du roi (ou semi-ouvertes)
	- Structures de pions :
		- Pions arriérés
		- Pion faible sur une colonne semi-ouverte
	- Nature de la position :
		- Ouverte
		- Fermée
		- Semi-ouverte
	- Evaluation spéciale pour les finales :
		- Fous de couleurs opposées
		- Finales roi pion
		- Mat fou cavalier
		- ...
	- Clouages?
	- Cases noires/blanches -> faiblesse sur une couleur
	- Cases faibles
	- Initiative -> A améliorer : fort dans les positions d'attaque?
	- Fous de couleurs opposées : favorisent l'attaque, mais en finale -> draw
	- Harmonie des pièces (qui se défendent entre elles)
	- Pièces enfermées
	- Bon/Mauvais fou
	- Tours sur une même colonne qu'une dame ou un roi
	- Pions bloqués / Développement de pièces impossible
	- Fous/Paire de fou meilleurs en position ouverte (cavalier : inverse)
	- Pièces défendues
	- Faiblesse sur une couleur
	- Vis-à-vis
	- Focales
	- Cavaliers bloqueurs
	- Finales de pions : Roi dans le carré
	- Garder les tours pour faire nulle
	- Clouage infini
	- Pression sur les cases et points faibles
	- Colonnes occupées par une dame
	- Pions passés liés !
	- Outpost
	- Coordination des pièces
	- Bishop pawns : nombre de pion de la même couleur que le fou -> pénalité plus le nombre est grand
	- Candidats pions passés : r1bq2kr/ppp1bn1p/2n1p2P/3pP1PR/3P1p2/1NPB1N2/PPQ2P2/R3K3 b Q - 0 16 : ici y'aura potentiellement un pion passé colonne g ou h
	- King proximity : proximité du roi avec les pions passés (pour les aider à avancer) (prendre en compte aussi le roi adverse)
	- Pièces non protégées
	- Shelter strength : pions devant le roi (faiblesses long terme), quand le roi est déroqué
	- Shelter storm : attaques avec les pions sur le roi quand il est déroqué
	- "anaconda" : pièces bloquées à vie + avantage d'espace etc.. plans long termes
	- Concepts de pression: attaques additionelles en rayon X à prendre en compte. Doubler les tours sur une colonne, etc...
	- Tours: les mettre sur les colonnes ou les pions sont les plus avancés (activité verticale)
	- Plans?
	- Colonnes fermées -> tour mauvaises. Si beaucoup de colonnes ouvertes, bonus pour les tours. Pareil pour les diagonales et les fous
	- Pions passés: prendre en compte les contrôles des alliés pour pousser les pions
	- Règle des 2 faiblesses : si y'a 2 faiblesses attaquables, ça donne un avantage
	- Winnable? en endgame par exemple si on a qu'un fou on peut pas gagner

-> Faire une policy pour les coups (ou des préférences de réflexion)
-> Livres d'ouvertures, tables d'engame?
-> Tables de hachages, et apprentissage de l'IA? -> voir tp_jeux (UE IA/IRP)
-> Iterative deepening pour grogrosfish
-> Améliorations pour trouver les mats les plus rapides... 
-> Ne plus regarder les branches finies de GrogrosZero?
-> Utiliser raylib pour le random? check la vitesse
-> Création d'une base de données contenant des positions et des évaluations? (qui se remplit au cours des parties...)
-> Allocations mémoires utilisant raylib?
-> Implémentation de bitboards
-> Changer la structure de données des boards pour réduire leur taille
-> Incrémentation de l'évaluation quand on joue les coups (make_move(keep))
-> Utiliser la librairie boost
-> Faire une liste séparée pour les legal et les pseudo-legal moves
-> Génération des coups de façon ordonnée? (captures en premier?)
-> Finir les undo
-> Mettre des options pour certaines fonctions pour ne pas faire les étapes inutiles (_last_move dans make_move??)
-> Faire une fonction pour initialiser un plateau (plutôt que le from_fen)
-> Faire que les undo gardent les calculs de GrogrosZero sur la position
-> Augmenter les poussées de pions en finale (les regarder en premier -> policy / move sort)
-> Faire une IA qui apprend tout seul? : update l'évaluation d'une position en fonction de la refléxion sur cette même position
-> Générer un arbre d'ouvertures !! :DDDD
-> Evaluation des pièces : prendre en compte les pièces protégées / attaquées? Pièces prenables?
-> Format du livre d'ouvertures : {(e4, fen, static_eval, dynamic_eval, nodes, {(e5, ...), (...), ...}), (d4, ...), ...}. où e4 = 1, 4, 3, 4
-> Pour l'utilisation du livre, re fabriquer un arbre?
-> Faire une table de hachage pour simplifier (et accélérer) la recherche des positions répétées
-> Pour l'historique des positions, on peut le reset à chaque coup de pion ou capture
-> Pour les transpositions, on peut peut-être renvoyer au même indice de plateau fils...?
-> Pour chaque plateau, générer et stocker la representation simpliste du plateau? Pour ensuite pouvoir aider les fils à comparer?
-> ATTENTION aux conversions int et float dans les calculs d'évaluations...
-> Mettre les règles de parties nulles et mat en dehors de l'évaluation?
-> Ajouter les pièces protégées/attaquées lors de l'évaluation pour simplifier les calculs de l'IA
-> Carré du pion en finales
-> Ne comprend pas les finales de bases (du au fait qu'il répète les coups?)
-> Regarder dag chess?
-> Faire une map des cases attaquées (ça peut rendre plus rapide les tests d'échecs)
-> OpenAI propose un diviser pour reigner pour paralléliser GrogrosZero
-> Est-ce plus rapide de mettre des boucles simples plutôt que double? while plutôt que for?
-> Endgame : la force des pièces dépend du potentiel des pions (pièces seules = bof)
-> Faire des tables d'attaque (par exemple entre roi et dame, cavalier...)
-> Refaire toute l'architecture avec les get_moves(), pour que ça prenne tout en compte (sans le faire dans l'évaluation)
-> Calculer l'avancement de la partie au fur et à mesure de la partie (au lieu de le faire à chaque fois)
-> GrogrosZero ralentit beaucoup quand les variantes deviennent longues
-> ----> Faire une recherche spécialement de mat, où on prend plus en compte le matériel??
-> Au fil de la réflexion, retirer les coups pourris?? pour augmenter la capacité de stockage...
-> Mettre une variable globale pour la règle des 50 coups (pour la passer à moins, si besoin)
-> Rechercher large au début, puis serré après??
-> Changer un peu l'algo, pour que ça ne joue pas forcément le coup auquel il a le plus réflechi, mais un autre si il semble être meilleur (quand c'est mat, facile, mais sinon, comment savoir?)
-> Attaquer les faiblesses
-> Quand Grogros joue un coup auquel il n'avait pas pensé.. les évaluations déscendent pour les coups, 1 par 1... comment faire pour que tout descende en même temps?
-> L'éval statique en position symétrique sera toujours nulle ?? (modulo le trait du joueur)
-> Puissance de la paire de fou qui dépend du moment de la partie? Qui dépend si y'a encore les dames pour compenser?
-> Découper la foncion draw en plein de sous-fonctions?
-> Chercher ce qui prend le plus de temps dans la GUI
-> Recherche de Grogros : utiliser UCT
-> Tester Grogros sur les leçons stratégiques de chess.com
-> Mettre des static const un peu partout pour éviter les re définitions inutiles
-> Faut-il prendre en compte le nombre de noeuds dans un fils pour déterminer s'il faut regarder dedans?
-> Ordonnencement des coups : checks/captures/attacks
-> Dans les positions ou des pièces peuvent être capturées, Grogros évalue très mal (quiescence depth trop faible)
-> Retirer les espace dans les parsing de FEN (ou autres caractères non désirés)
-> Passer tous les commentaires en anglais et clean le code?
-> Evaluations en finales : un cavalier seul sans pions ni rien = nul
-> Mettre les noms de version sur le nom de Grogros
-> Utiliser toutes les améliorations/optimisations possibles sur VisualStudio
-> Mettre des uint_fast8_t partout
-> Negamax : utiliser les plateaux tout faits du buffer?
-> Mettre des variables globales partout !
-> Virer les attributs inutiles des plateaux
-> Faire une fonction qui regarde si un coup est légal
-> Regarder et virer toutes les conversions de int à float, et opérations entre int et floats
-> Position à tester : GrogrosZero vs Grogrosfish : 
	-> r1bqkb1r/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 : sans cavaliers
	-> rn1qk1nr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 : sans fous
	-> 1nbqkbn1/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w - - 0 1 : sans tours
	-> rnb1kbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 : sans dame
	-> rnbqkbnr/8/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 : sans pions
-> Faire des pre-calculs dans des constantes (genre des divisions), pour éviter de les faire à chaque fois
-> Mettre des flags pour les coups (capture, check, promotion -> caval possible??)
-> Descendre un peu le winrate par éval? réference : +1.00 = 50% de chances de gain
-> Quels paramètres sont meilleurs pour GrogrosZero? k_add? beta? quiescence_depth?
-> Utiliser std:sort pour trier les coups plus rapidement?
-> Alignement de pièces à finir (tour/roi, tour/dame...)
-> Taper les faiblesses (notions de pression)
-> Réduire la puissance des fous : un cavalier bien placé peut être tout aussi bon -> Outpost
-> Utiliser la map de contrôles pour les fonctions dans l'évaluation
-> Quand l'arbre est trop plein : élaguer les branches pourries, pour se concentrer sur les plus prometteuses
-> Faut-il vraiment regarder tous les coups d'une position avant de chercher plus loin??
-> Evaluer les finales différemment : faires des fonctions exprès pour (carré du pion, mat fou cavalier : il faut aller dans le bon coin)
-> Optimiser la mémoire de Grogros
-> Ajouter la nature de la position : ouverte, fermée... pour savoir à quel point les fous/cavaliers sont meilleurs, si y'a des chances de gain, si le développement des pièces compte beaucoup... l'espace aussi, la sécurité des rois...
-> Améliorer l'implémentation de l'activité des pièces : peuvent pas vraiment se déplacer sur des cases pourries...
-> Pour mieux évaluer la sécurité du roi, il faut regarder le surnombre de pièces sur le roi adverse (+2, c'est généralement mat)
-> Pourquoi dans les Caro-Kann, il fait Fd3 pour reprendre du pion c plutôt que de la dame?
-> Faire que Grogros reclique sur la fenêtre principale après jouer son coup sur chess.com pour reprendre la main? ou alors faire un focus sur la fenêtre?
-> Utiliser des static constexpr pour éviter des calculs redondants dans certaines fonctions
-> Il faut plus de g3 Fg2 -> revoir king safety?
-> Re utiliser la réflexion de la quiescence search pour la recherche normale
-> Faire evaluation.cpp? gui.cpp?
-> Comme pour le roi, garder en mémoire l'emplacement des pièces (utiliserait 256 bytes)
-> Afficher seulement les paramètres d'évaluation qui font sens? (par exemple king opposition seulement lorsque c'est une finale de pions)
-> Tout foutre dans la classe GUI? les variables globales et fonctions globales en particulier -> par exemple eval_components
-> Adapter les fonctions aux coups (make_move(Move)...)
-> Faire des méthodes utiles pour les coups
-> Verifier que quiescence depth 0 est aussi rapide qu'une simple évaluation
-> Flags pour les coups
-> Rendre from_fen plus tolérant
-> Améliorer l'évaluation en faisant jouer contre Leela, et regarder ce que Grogros évalue mal
-> Eviter les accès à _moves[i] trop souvent? -> copier le coup?
-> IMPORTANT : refaire toutes les recherches de mat, et leur stockages
-> Faire le threading !
-> Faire un king_centralization pour l'endgame?
-> Voir comment gérer les positions qui sont mal évaluées par GrogrosZero
-> Implementer les policy pour les coups (pour regarder des coups plus que d'autres)
-> Pion de moins en finale de pions est quasi toujours perdant
-> Ajouter la pièce dans le coup (et l'utiliser)
-> Revoir les undo, et les faire rapides pour les utiliser au lieu de copier les plateaux
-> Faire des tests de vitesse pour l'évaluation
-> Evaluation endgame très mauvaise
-> Quand une position est surestimée, Grogros va jouer des coups pour retarder l'échéance, mais qui peuvent pourrir la position encore plus
-> Quand une position est sous-estimée, Grogros va jouer un coup qui parait bien et réfléchir beaucoup dessus, même si d'autres variations peuvent être meilleures
-> Revoir negamax
-> Utiliser sort c++ pour trier les coups
-> Rajouter les coups du quiescence dans monte-carlo, et inversement... -> mettre le quiescence dans MCTS?
-> Remettre la dame dans la mobilité des pièces et l'activité? pour que ça développe la dame aussi? Sinon, ça évalue mal ces positions: r1b1kbnr/ppqp1ppp/2n1p3/8/3NP3/2N5/PPP2PPP/R1BQKB1R w KQkq - 1 6 
-> r1bqkb1r/ppp2ppp/2n1p3/8/3PP3/2P5/P4PPP/R1BQKBNR w KQkq - 0 7 : piece_mobility seulement +0.18? c'est un bug?
-> Dans la recherche de grogros_zero, regarder en priorité les coups forts et peu regardés
-> Detection plus rapide d'échecs et mat
-> Regarder où on fait des accès mémoire fréquent et faire des copies locales pour aller plus vite?
-> Refaire la partie sur attacks and defenses... pour que ça soit plus précis.. là si on tape un pion protégé, ça fait un bonus...
-> Lorsqu'une position est mal évaluée, ajouter une constante de correction d'évaluation pour toutes les positions résultantes (ou jusqu'à ce que l'évaluation soit bonne)
-> King safety, safe checks: FIXME -> ça prend pas en compte les échecs à la découverte, ni les échecs par clouage
-> Faire quelques playoff jusqu'au bout pour avoir une idée de la nature de la position??
-> Fix pawn push threat : quand la case est controllée...
-> Passer la quiescence à depth 8 ou +? sinon y'a encore des positions mal évaluées... à voir si on peut réutiliser les noeuds de la quiescence pour la recherche normale
-> Créer une classe 'arbre' pour les recherches de GrogrosZero?
-> 6k1/4pp1p/P2p2p1/8/4P3/1P6/5PPP/6K1 b - - 0 26 : il faut améliorer king proximity avec les pions passés: le roi est clairement pas dans le carré
-> Constructeur de coups à partir d'un string
-> Passer les fonctions d'évaluation dans evaluation.cpp
-> Changer tous les play_move(i) en play_move(move)
-> Il faut vider l'historique des variantes quand on change de position... faire une méthode pour reset?
-> Mettre plus de choses dans GUI.cpp
-> Refaire le tri des flèches
-> Refaire toutes la fonction de dessin de la GUI (notamment pour clarifier les sélections.. puis faire les pre-moves..., draw arrow...)
-> Rajouter 'overwrite' en paramètre de la génération de coups
-> Ne pas jouer le coup quand un autre est en train de devenir meilleur?
-> Changer l'activité des pièces? -> Faire comme pour les tours, regarder en fonctions des pions qu'il y a devant?
-> Punir la perte des droits de roques -> si le roi est au milieu
-> Structure de pions (connected -> -?)
-> King safety en endgame -> wtf parfois
-> 7k/4r3/5pBP/p1n5/P6P/1P2PK2/5P2/8 b - - 3 51 : king safety??????
-> Rajouter des comtempt: valeur qui dépend de l'adversaire, et qui définit à quel point tu acceptes les nulles (et tente des pièges?)
-> Faire une structure pour la recherche de MonteCarlo (arbre avec noeuds)
-> Bishop pawns: retirer une part de la pénalité quand le fou est devant et protégé par un de ses pions?
-> FIXME : pour l'activité des tours, parfois Grogros va faire un Th7 pour se déroquer (car il pense que sa tour ne sera plus bloquée). Il faut fix à tout prix
-> Souvent, Grogros dépasse le centre pour rien, et ça crée des faiblesses et ne sert à rien (il faudrait mieux se développer à la place...). Contre les double fianchetto, ce genre d'erreur est fatal
-> Utiliser des émoticones pour les pièces d'échec? \u2656xb5 plutôt que Rxb5
-> Faire des plus petites allocations de buffer pour aller plus vite? et re allouer de la mémoire si on a rempli le buffer?
-> Faire un truc sur la mobilité totale des pièces? qui ressemble à un logarithme? -> t'as pas de coups -> eval: -inf, t'as k coups -> eval: 0, et ça augmente en log
-> Utiliser Texel tuner pour rectifier l'évaluation?
-> Mettre les fous sur les diagonales ouvertes (voir comme on fait pour les colonnes des tours)
-> 2b3k1/4bp2/3p1n1p/PP4p1/4P1P1/3BBP2/5K1P/8 w - - 1 36 : les pions connectés fonctionnent bien?
-> Heuristique pour à quel point le roi est proche de roquer?
-> Heuristique d'ouverture de la position -> draw ou non
-> Grogros peut améliorer sa gestion du temps en en prenant un peu plus en fin de partie s'il lui en reste beaucoup. Prendre en compte aussi le temps de l'adversaire?
-> Rajouter les pions passés soutenus par une tour derrière
-> En finale contre fou, mettre les pions sur la couleur opposée au fou
-> Parfois il fait Fb2 dans le pion c3
-> Remettre toutes les conditions pour determiner le temps pour jouer dans la fonction prévue pour
-> Beaucoup de choses peuvent être factorisées dans le main_gui (get_orientation() par exemple)
-> Bug: quand on lance les threads de Grogros lorsque le buffer est plein, ça plante


----- Interface utilisateur -----

-> Faire un readme pour les contrôles
-> Amélioration des sons (en faire des maison?)
-> Nouveau sons/images
-> Dans le negamax, renvoyer le coup à chaque fois, pour noter la ligne que l'ordi regarde?
-> Faire des boutons pour faire des actions (ex copier ou coller le FEN/PGN, activer l'IA ou la changer...)
-> Options : désactivation son, ...
-> Chargement FEN -> "auto-complétion" si le FEN est incorrect
-> Régler le clic (quand IA va jouer), qui affiche mal la pièce (grogrosfish)
-> Modification de l'incrément dans la GUI
-> Interface qui ne freeze plus quand l'IA réfléchit -> Paralléliser
-> Sons pour le temps
-> Premettre de modifier les paramètres de recherche de l'IA : beta, k_add... (d'une meilleure manière)
-> Musique de fond? (désactivable)
-> Ajouter un éditeur de positions (ajouter/supprimer les pièces)
-> Utiliser 1 thread pour gérer l'affichage tout seul
-> Undo doit retirer le coup du PGN aussi
-> Afficher les textes avec des différentes couleurs pour que ça soit plus facile à lire
-> Défiler la variante quand on met la souris dessus
-> Montrer sur l'échiquier quand la position est mate (ou pate, ou autre condition de fin de partie)
-> Faire un reconnaisseur de position automatique
-> Unload les images, textures etc... pour vider la RAM?
-> Pouvoir changer les paramètres de l'IA dans l'UI
-> Ajouter des options/menus
-> Pouvoir sauvegarder les parties entières dans un fichier (qui s'incrémente), pour garder une trace de toutes les parties jouées
-> Analyses de MC : montrer le chemin qui mène à la meilleure éval, puis celle qui mène au jeu qui va être joué
-> Pouvoir grab le slider, ou cliquer pour changer sa place
-> Faire des batailles entre différents paramètres d'évaluation pour voir la meilleure config -> Retour des batailles de NN?
-> Importation depuis un PGN
-> Afficher sur le PGN la reflexion de GrogrosZero
-> Pouvoir changer le nombre de noeuds de l'IA dans la GUI... ou la profondeur de Grogrosfish
-> Parfois l'utilisation des réseaux de neurones bug
-> Nd2f3 -> Ndf3? pas facile à faire
-> Ajouter la possibilité de faire plusieurs pre-move
-> Faire du smooth sur la barre d'évaluation
-> Faire un graphe d'éval en fin de partie?
-> Mettre des + sur les flèches (comme il y'a des -...)?
-> Faire un fonction pour tranformer une éval en son texte (mat ou non)
-> Certains calculs sont peut-être en double dans l'affichage
-> Echelle logarithmique pour la barre d'éval?
-> Gestion du temps bizarre? Car le temps affiché par GrogrosZero n'est pas vraiment le vrai (ni sa vitesse)
-> Clean l'implémentation de la GUI -> Faire des nouvelles fonctions pour tout simplifier
-> Faire un vecteur pour les pre moves et les flèches
-> Fins de parties : message + son
-> Dans une position que GrogrosZero sous-évalue, jouer le coup auquel il a le plus réflechi. dans le cas contraire, jouer le coup avec la meilleure éval
-> Barre d'éval : barre pour l'évaluation du coup le plus recherché par l'IA? ou éval du "meilleur coup"?
-> Mettre le screenshot dans le presse-papier?
-> Faire un truc pour montrer la menace (changer le trait du joueur)
-> Pouvoir éditer les positions
-> PARALLELISER L'AFFICHAGE !! ça lag beaucoup trop !!!
-> Refaire les pre-moves depuis zéro (et ajouter la possibilité d'en faire plusieurs)
-> Trop de flèches = crash
-> Lignes de bézier et cercles pas très beaux
-> Nouveaux bruits de pièces plus "soft" + bruit d'ambiance?
-> Montrer toute la variante calculée avec des flèches (d'une couleur spéciale)
-> Thread : bug... parfois les coups joués ne sont pas les bons
-> Re foncer le noir des pièces?
-> Pourquoi dans certaines variantes, l'éval ne s'affiche pas à la fin??
-> Dans les .h, remettre les noms des arguments?
-> Rajouter des pre-moves pour Grogros si c'est un coup forcé en face
-> Pourquoi c'est lent de changer la taille de la GUI?
-> Pour la barre d'éval, on utiise le winrate?
-> Faire des maps pour afficher les paramètres d'évaluation (genre afficher les cases controllées, avec une couleur plus ou moins prononcée...)
-> Pouvoir facilement changer les paramètres de Grogros (quiescence depth, beta, k_add, paramètres d'évaluation...)
-> Pouvoir changer l'affichage de la GUI (winrate/eval)
-> Faire des menus
-> Désélectionner les pièces lors d'un chargement de position
-> Utiliser des checkCollision de raylib pour la GUI
-> Afficher l'incrément de temps sur la GUI, et pouvoir le modifier
-> O-O+ dans les move label à prendre en compte
-> Revoir les update du temps quand on le change pendant que ça joue
-> Afficher des traits autour du plateau chess.com?
-> Affichage de la réflexion de Grogros sur le PGN : {N: 10.29% of 544}
-> Revoir le compare moves (sinon ça affiche pas toujours le meilleur coup au dessus)
-> Adapter nodes_per_frame en fonction du temps de réflexion de GrogrosZero (tant que la parallélisation n'est pas faite)
-> Montrer l'incrément sur la GUI
-> Afficher le titre et l'elo des joueurs sur la GUI
-> Revoir le tri des coups pour les flèches de GrogrosZero, car parfois ça ne se trie pas bien
-> Afficher différement la pièce sélectionnée (et au dessus des autres pièces)
-> Faire des animations de Grogros qui bouge les pièces
-> Quand on joue un coup (en appuyant sur p ou autre), il faut désélectionner la pièce
-> Refaire la réflexion de GrogrosZero: quand il y a beaucoup d'incertitude dans l'éval, regarder large. Sinon, regarder profond
-> Mobilité verticale ~= activité pour les tours?
-> Vérifier qu'il n'y a pas d'int overflow dans la sélection des coups (softmax...)
-> rnb2bnr/pppp1k1p/5q2/8/5p2/2N1BQ2/PPP3PP/R4RK1 b - - 3 11 : il évalue mal, et teste les coups 1 par 1 et se rend compte que ça va pas... beaucoup trop lent à ré évaluer la position correctement.
-> Changer l'affichage du plateau en fonction de l'arbre de jeu, et le fils principal (surligner le coup)
-> Barre d'éval : afficher l'éval du coup le plus recherché par l'IA? ou éval du "meilleur coup"?
-> Time management: faire en fonction de la différence entre le meilleur coup et les autres pour jouer plus vite? Debug pour voir si tout fonctionne bien
-> Afficher l'endroit où on en est dans la variante, pouvoir cliquer dessus, changer les variantes
-> Dé-surligner le coup quand on navigue dans les coups
-> From_fen -> reset l'arbre
-> Surligner le coup principal de la variante
-> Parfois des positions buggent quand on navigue.. ça affiche des pièces en énorme (à cause de la réflexion de Grogros qui a supprimé le coup?)
-> Remettre les chronos dans le PGN généré par l'arbre (et les noeuds, et d'autres notations?)
-> Garder les réflexions de GrogrosZero quand on navigue dans les coups
-> Parfois quand on revient en arrière, ça reprend sur la mauvaise variation
-> Passer une variante en principale
-> Montrer quand une ligne d'analyse est montante ou descendante
-> Parallélisation: faut que les quiescence nodes augmentent aussi
-> Quand on navigue dans la partie, jouer les son
-> Afficher en vert, orange ou rouge les forces et faiblesses de la positions?
-> BUG: quand on clique sur une flèche non visible, ça joue quand-même le coup



----- Grosses implémentations à faire -----

-> Table de transposition
-> Bitboards
-> Réseaux de neurones
-> Parallélisation (possible sur le GPU?)
-> Policy pour les coups
-> "Killer moves", ou gestion des menaces
-> Fusion de la quiessence search et de la recherche normale (IMPORTANT)
-> Arbres de variations / Chargement de PGN
-> Livre d'ouvertures
-> Beaucoup de vérifs à faire dans les fonctions principales (make_move, grogros_zero...)
-> On peut réduire la taille des coups en groupant par 2 coordonnées


----- En cours -----

-> move_keep: virer le plateau du buffer
-> Table de transposition
-> Promotion de variantes: il faut repasser sur la variante principale au moment de la promotion
-> Promotions de variantes -> il faut promouvoir toute la branche depuis le début, pas juste le dernier coup (+ le FIXME -> il faut sélectionner le bon noeud après la promotion)
-> Pawn storm / Pawn shield (rajout des colonnes/diagonales ouvertes etc...) / Pions arriérés / Fix king safety / Pieces alignement (à finir)
-> Affichage du temps dans le PGN
-> Quiescence nodes qui augmente aussi avec les threads
-> Temps affiché = vrai temps
-> Afficher les pièces plutôt que P, R, N, B, Q, K
-> Placer les fonctions dans gui.cpp


----- Réseaux de neurones -----

-> Faut t-il de la symétrie dans le réseau de neurone? (car sinon il évalue pas de la même manière les blancs et les noirs)
-> Comment le faire apprendre?
-> Parties contre lui-même
-> Algorithme génétique: on détruit les plus faibles, et on fait des mutations sur les plus forts
-> Bonus et malus pendant les parties, lorsqu'il a mal évalué une position
-> Apprentissage à partir des fins de partie, puis on remonte
-> Reinforcement learning